<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java位运算]]></title>
    <url>%2F2020%2F08%2F06%2FJava%E4%BD%8D%E8%BF%90%E7%AE%97%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[二进制，八进制，十进制，十六进制介绍及互相转换]]></title>
    <url>%2F2020%2F08%2F06%2F%E4%BA%8C%E8%BF%9B%E5%88%B6%EF%BC%8C%E5%85%AB%E8%BF%9B%E5%88%B6%EF%BC%8C%E5%8D%81%E8%BF%9B%E5%88%B6%EF%BC%8C%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E4%BB%8B%E7%BB%8D%E5%8F%8A%E4%BA%92%E7%9B%B8%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[艺术探索04-View的工作原理]]></title>
    <url>%2F2020%2F07%2F21%2F%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A204-View%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[Android开发艺术探索阅读梳理 第四章节 View的工作原理 本来Android给我们提供了一套GUI库，里面包含了很多控件。但为了做出与众不同的效果（产品/UI作妖），这些是远远不够的。这个时候就需要用到自定义View.我们需要掌握：1.View的三大流程 2.View的常见回调方法3.处理滑动事件和滑动冲突4.自定义View的几种固定类型 初识ViewRoot和DecorView ViewRoot和DecorView 基本概念的了解，方便于我们更好的了解View的measure，layout，draw过程。 ViewRootViewRoot对应于ViewRootImpl类，是连接WindowManager和DecorView的纽带。View的三大流程都是通过ViewRoot来完成的。在ActivityThread中，当Activity对象被创建完成后，会将DecorView添加到Window中，同时会创建ViewRoot对象。并将ViewRootImpl对象和DecorView建立关联。 View的绘制流程是从ViewRoot的performTraversals方法开始的，如下图：measure测量View的宽和高 measure完成后，可通过getMeasureWidth和getMeasureHeight获得View测量后的宽高 layout确定View在父容器中的位置 layout完成后，可通过getTop,getBottom,getLeft,getRight获得View四个顶点的位置可通过getWidth和getHeight获得View最终的宽高 draw将View画在屏幕上 draw完成后，View才会显示在屏幕上 ###DecorViewDecorView上章有过了解，他是顶级View,一般情况下它内部包含一个竖直的LinearLayout，其中包含一个标题栏，一个内容栏，内容栏的id是content，可以通过 1ViewGroup content=fidViewById(android.R.id.content) 来获得。如果有朋友研究过加载/空白/错误组合页面，会发现有些人是通过获取到content后填充的。 理解MeasureSpec MeasureSpec 翻译过来“测量规格”，也确实是字面上的意思，MeasureSpec参与了measure过程，很大程度上决定了View的尺寸规则。View的尺寸规则还受到父容器影响。这是因为MeasureSpec是由View的LayoutParams根据父容器所施加的规则转换而来。 MeasureSpec从MeasureSpec的定义我们可指定，它封装了对子View的布局要求，由尺寸和模式组成；MeasureSpec代表一个32位的int值高2位代表SpecMode，指测量模式低30位代表SpecSize，指某种测量模式下的规格大小 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public static class MeasureSpec &#123; private static final int MODE_SHIFT = 30; private static final int MODE_MASK = 0x3 &lt;&lt; MODE_SHIFT; /** @hide */ @IntDef(&#123;UNSPECIFIED, EXACTLY, AT_MOST&#125;) @Retention(RetentionPolicy.SOURCE) public @interface MeasureSpecMode &#123;&#125; public static final int UNSPECIFIED = 0 &lt;&lt; MODE_SHIFT; public static final int EXACTLY = 1 &lt;&lt; MODE_SHIFT; public static final int AT_MOST = 2 &lt;&lt; MODE_SHIFT; public static int makeMeasureSpec(@IntRange(from = 0, to = (1 &lt;&lt; MeasureSpec.MODE_SHIFT) - 1) int size, @MeasureSpecMode int mode) &#123; if (sUseBrokenMakeMeasureSpec) &#123; return size + mode; &#125; else &#123; return (size &amp; ~MODE_MASK) | (mode &amp; MODE_MASK); &#125; &#125; public static int makeSafeMeasureSpec(int size, int mode) &#123; if (sUseZeroUnspecifiedMeasureSpec &amp;&amp; mode == UNSPECIFIED) &#123; return 0; &#125; return makeMeasureSpec(size, mode); &#125; @MeasureSpecMode public static int getMode(int measureSpec) &#123; return (measureSpec &amp; MODE_MASK); &#125; public static int getSize(int measureSpec) &#123; return (measureSpec &amp; ~MODE_MASK); &#125; static int adjust(int measureSpec, int delta) &#123; final int mode = getMode(measureSpec); int size = getSize(measureSpec); if (mode == UNSPECIFIED) &#123; return makeMeasureSpec(size, UNSPECIFIED); &#125; size += delta; if (size &lt; 0) &#123; size = 0; &#125; return makeMeasureSpec(size, mode); &#125; 从源码可以看到，内部定义了很多常量，从API17以后开始采用位运算，提高效率。自定义StringBuilder和StringBuffer]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android开发艺术探索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[艺术探索03-View的事件体系]]></title>
    <url>%2F2020%2F07%2F14%2F%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A203-View%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB%2F</url>
    <content type="text"><![CDATA[Android开发艺术探索阅读梳理第三章节 View的事件体系 View 基础知识什么是ViewView 是Android中所有控件的基类，可以看做是一种界面层的控件上的一种抽象。ViewGroup 字面意思View组，其内部可以包含多个子View/ViewGroup View的位置参数View 的位置主要是由它的四个顶点来确定。分别对应着View的四个属性 left getLeft() top getTop() right getRight() bottom getBottom() 这几个属性的坐标都是原始状态时相对于父容器而言,所以对View进行移动操作并不会改变这四个方法的返回值。如下图所示 如果想要获得这四个返回值，不可在onCreate()中获取，因为View的显示必须经过Measure(测量)，Layout(布局)和Draw(绘制)的过程。这几个过程都晚于onCreate（） 方法1：开启一个线程，在线程中获取 方法2：重写Activity的onWindowFocusChange（） 方法3：为View注册监听器onGlobalLayoutListener Android3.0开始，View增加了几个参数： x ：getX() View 左上角的X轴坐标 y ：getY() View 左上角的Y轴坐标 translationX ：getTranslationX() View左上角相对于父容器x轴的偏移量，默认是0 translationY ：getTranslationY() View左上角相对于父容器y轴的偏移量，默认是0 Android api = Build.VERSION_CODES.LOLLIPOP以上时 translationZ ：getTranslationZ() View的深度 MotionEvent和TouchSlopMotionEvent重写onTouchEvent（MotionEvent event）方法时，Android会把触摸事件封装成MotionEvent提供给我们。 ACTIVITY_DOWN 手指刚接触屏幕 ACTIVITY_MOVE 手指在屏幕上滑动 ACTIVITY_UP 手指离开屏幕 此外还提供了2组坐标给我们 getX()/getY() 触摸点相对于当前View的左上角的X/Y轴坐标 getRawX()/getRawY() 触摸点相对于手机屏幕左上角的X/Y轴坐标 TouchSlopTouchSlop 是系统能够识别出的滑动最短距离，小于这个，系统就不认为你在屏幕上滑动了。可以用它做一些过滤操作。不同手机TouchSlop的值可能不相同，具体值可通过下面的方法获取： 1234/*** 小米手机上是22px*/ViewConfiguration.get(getApplicationContext()).getScaledDoubleTapSlop() VelocityTracker,GestureDetector和ScrollerVelocityTracker滑动速度跟踪器，可以用来监听手指移动过程中的速度基本用法：1，在View的onTouchEvent.ACTIVITY_DOWN里进行初始化 1234if(mVelocityTracker!=null)&#123; mVelocityTracker=VelocityTracker.obtain();&#125;mVelocityTracker.addMovement(event); 2,在View的onTouchEvent.ACTIVITY_MOVE里进行跟踪 1234mVelocityTracker.computeCurrentVelocity(1000);//必须先计算速度，及computeCurrentVelocity(1000)必须在getXVelocity(),getYVelocity()之前xVelocity = (int) mVelocityTracker.getXVelocity();yVelocity = (int) mVelocityTracker.getYVelocity(); 该速度指的是*时间内，手指滑动过的像素数。（也有可能是负数，根据坐标轴方向和手指滑动方向确定）3，在View的onTouchEvent.ACTIVITY_UP里进行清除回收内存 12mVelocityTracker.clear;mVelocityTracker.recycle; GestureDetector手势检测，用于辅助检测用户的单击，滑动，双击等动作常用方法不是很多，且可以在onTouchEvent中进行实现所需监听。如果只是监听滑动，不需要使用。使用方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/*** 实现OnGestureListener()接口*///1，创建对象实现接口mGestureDetector=new GestureDetector(this, new GestureDetector.OnGestureListener() &#123; @Override public boolean onDown(MotionEvent e) &#123; return false; //手指轻轻触摸的一瞬间，由一个ACTIVITY_DOWN触发 &#125; @Override public void onShowPress(MotionEvent e) &#123; //手指轻轻触摸屏幕，尚未松开或拖动，由一个ACTIVITY_DOWN触发 //和onDown的区别：他强调的是没有松开或拖动 &#125; @Override public boolean onSingleTapUp(MotionEvent e) &#123; return false; //手指轻触屏幕后松开，伴随着ACTIVITY_UP //是单机行为 &#125; @Override public boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY) &#123; return false; //手指按下屏幕并拖动 //由一个ACTIVITY_DOWN多个ACTIVITY_MOVE触发 &#125; @Override public void onLongPress(MotionEvent e) &#123; //长按 &#125; @Override public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) &#123; return false; //用户按下屏幕，快速滑动后松开 //由一个ACTIVITY_DOWN多个ACTIVITY_MOVE一个ACTIVITY_UP触发 &#125; &#125;); //解决长按屏幕后无法拖动的现象 mGestureDetector.setIsLongpressEnabled(false); //2,在view的onTouchEvent中添加 mTextView.setOnTouchListener(new View.OnTouchListener() &#123; @Override public boolean onTouch(View v, MotionEvent event) &#123; mGestureDetector.onTouchEvent(event); return false; &#125; &#125;); ####Scroller弹性滑动对象，用于实现View的弹性滑动，需要配合View的computeScroll方法。 View的滑动因为手机屏幕较小，所以滑动在我们开发中占用了很大比重常见的滑动方式有三种：1，通过View自身的scrollTo/scrollBy方法2，通过动画给View添加平移效果3，通过改变View的LayoutParams使View重新布局接下来一一介绍 使用scrollTo/scrollBy首先看下源码明确俩个问题1,怎么滑？2,滑动方向？ 12345678910111213141516171819202122232425262728293031/** * Set the scrolled position of your view. This will cause a call to * &#123;@link #onScrollChanged(int, int, int, int)&#125; and the view will be * invalidated. * @param x the x position to scroll to * @param y the y position to scroll to */ public void scrollTo(int x, int y) &#123; if (mScrollX != x || mScrollY != y) &#123; int oldX = mScrollX; int oldY = mScrollY; mScrollX = x; mScrollY = y; invalidateParentCaches(); onScrollChanged(mScrollX, mScrollY, oldX, oldY); if (!awakenScrollBars()) &#123; postInvalidateOnAnimation(); &#125; &#125; &#125; /** * Move the scrolled position of your view. This will cause a call to * &#123;@link #onScrollChanged(int, int, int, int)&#125; and the view will be * invalidated. * @param x the amount of pixels to scroll by horizontally * @param y the amount of pixels to scroll by vertically */ public void scrollBy(int x, int y) &#123; scrollTo(mScrollX + x, mScrollY + y); &#125; 看源码可知：1，scrollBy调用了scrollTo,是相对于目前位置的相对滑动2，scrollTo是绝对滑动想要理解怎么滑，就要明白mScrollX和mScrollY是什么 mScrollX:View内容左边缘到View左边缘的水平距离 mScrollY:View内容上边缘到View上边缘的素质距离 也就是说想要操控View内容，需要View去scrollTo/scrollBy且滑动方向是相反的，这一点我们根据源码也可以看出,他指的是移动的坐标量，最后还是要做转换的 1234567@Deprecated public void invalidate(Rect dirty) &#123; final int scrollX = mScrollX; final int scrollY = mScrollY; invalidateInternal(dirty.left - scrollX, dirty.top - scrollY, dirty.right - scrollX, dirty.bottom - scrollY, true, false); &#125; 使用动画主要是操控View的translationX和translationY来实现 使用View动画也就是新建一个anim,标签是translate这种有个弊端，那就是移动过后，View的点击事件还留在原点。 使用属性动画这个没啥说的，注意一下，适配3.0以下要使用开源库nineoldandroids（如果你需要适配3.0的话-_-） 改变布局参数也就是改变LayoutParams。 View的事件分发机制View的分发机制是解决View滑动冲突的基础，不了解这个GG 点击事件的传递规则首先明确下研究对象，点击事件即MotionEvent事件分发过程该过程通过三个重要的方法来共同完成 dispatchTouchEvent()用于事件的分发，如果事件传递到当前View，那么该方法一定被调用，返回结果取决于俩方面：1，当前View的onTouchEvent；2，下级View的dispatchTouchEvent表示是否消耗当前事件 onInterceptTouchEvent()在View内部中调用，用来判断是否拦截某个事件，如果当前View拦截了这个事件，返回true，那么在同一事件序列里，此方法不会被再次调用 onTouchEvent()在dispatchTouchEvent方法中调用，用来处理点击事件，如果不消耗，那么在同一事件序列中，当前View不会在接收到该事件 三者关系可用下方伪代码来表明 123456789public boolean dispatchTouchEvent(MotionEvent ev)&#123; boolean consume = false; if(onIntercceptTouchEvent(ev))&#123; //上层View的onIntercceptTouchEvent返回true,代表它要进行处理，onTouchEvent就会被调用， consume = onTouchEvent(ev); &#125;else&#123;//上层View的onIntercceptTouchEvent返回false，表示不处理，事件传递给下层View。 consume = child.dispatchTouchEvent(ev);//循环直至事件被处理 &#125; return consume;&#125; 简单做个类比。 阅读下面总结前，建议自己先写个demo打log跑一遍。这样才能真正理解。 同一个事件序列是指从手指接触屏幕的那一刻开始，到手指离开屏幕为止，在这个过程中产生的一系列事件。这个事件以down事件开始，若干个move事件，以up事件结束 正常情况下，一个事件序列只能被一个View消耗掉，除非自己不处理通过onTouchEvent强行传递给别的View 某个View一旦决定拦截，那么这一个事件序列只能被他处理，且它的onIntercepeTouchEvent不会被调用。 某个View一旦开始处理事件，如果它在onTouchEvent中不进行对ACTIVITY_DOWN事件消耗，那么同一个事件序列的其他事件都不会交给他完成 如果View不消耗除ACTIVITY_DOWN以外的事件，那么这个点击事件会消失，此时父元素的onTouchEvent并不会被调用，并且当前View可以持续收到后续的事件，最后这些消失的点击事件会传递给Activity处理。 ViewGroup默认不拦截任何事件 View没有onInterceptTouchEvent方法，一旦有点击事件传递给它，那么他的onTouchEvent方法就会被调用 View的onTouchEvent默认都会消耗事件，除非它是不可点击的（clickable和longClickable同时false）View的longClickable默认是false，clickable分情况，比如button的为true，textview的为false View的enable属性不影响onTouchEvent的默认返回值，哪怕是一个View是disable状态的，只要他的clickable和longClickable只要有一个是true，那么他的onTouchEvent就会为true onClick会发生的前提是当前View可点击，并且它收到了down和up事件 事件传递过程是由外向内的，即事件总是先传递给父元素然后在由父元素分发给子View。通过requestDisallowInterceptTouchEvent方法可以在子元素中干预父元素的事件分发过程，但ACTIVITY_DOWN事件除外。 记住上面总结的编号，下面开始源码梳理 事件分发的源码解析首先要明确下，一个点击事件的分发过程是由外向内的，即Activity-ViewGroup-View Activity对点击事件的分发过程。当一个点击事件开始传递时，首先Activity的dispatchTouchEvent进行接管分发 123456789101112//源码位置：Activity#dispatchTouchEvent public boolean dispatchTouchEvent(MotionEvent ev) &#123; if (ev.getAction() == MotionEvent.ACTION_DOWN) &#123; onUserInteraction(); &#125; //获得顶级View，也就是setContentView所设置的View的父容器（ViewGroup） //（getWindow().getDecorView().findViewById(android.R.id.Content)）.getChildAt(0) if (getWindow().superDispatchTouchEvent(ev)) &#123; return true; &#125; return onTouchEvent(ev); &#125; 通过getWindow().superDispatchTouchEvent(ev)可知具体是由Activiy的Window来完成的。跟踪到Window中的superDispatchTouchEvent，会发现该方法是抽象的 12//源码位置：Window#superDispatchTouchEvent public abstract boolean superDispatchTouchEvent(MotionEvent event); 再根据Window源码最上方的介绍可以得知，Window的实现类是PhoneWindow The only existing implementation of this abstract class is android.view.PhoneWindow, which you should instantiate when needing a Window. 12345//源码位置：PhoneWindow#superDispatchTouchEvent @Override public boolean superDispatchTouchEvent(MotionEvent event) &#123; return mDecor.superDispatchTouchEvent(event); &#125; 来了来了，可以看到PhoneWindow把事件直接传递到了mDecor，也就是DecorView这也就能够理的通了，为什么getWindow().getDecorView().findViewById(android.R.id.Content)）.getChildAt(0)可以获得Activity所设置的View现在点击事件已经传递给顶级的View了，也就是我们setContentView所设置的View. 顶级View对点击事件的分发过程。首先理一下逻辑：可见我们需要拿ViewGroup的dispatchTouchEvent开刀 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111//源码位置ViewGroup#dispatchTouchEventpublic boolean dispatchTouchEvent(MotionEvent ev) &#123; ... final int action = ev.getAction(); final int actionMasked = action &amp; MotionEvent.ACTION_MASK; //ACTION_DOWN时清除FLAG_DISALLOW_INTERCPT，设置mFirstTouchTarget为null if (actionMasked == MotionEvent.ACTION_DOWN) &#123; cancelAndClearTouchTargets(ev); resetTouchState(); &#125; //ViewGroup是否拦截事件 final boolean intercepted; //检查是否需要拦截 //1，是否是down事件 //2，是否有子View成功处理事件 if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) &#123; final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0; if (!disallowIntercept) &#123; intercepted = onInterceptTouchEvent(ev); ev.setAction(action); // restore action in case it was changed &#125; else &#123; intercepted = false; &#125; &#125; else &#123; intercepted = true; &#125; //如果ViewGroup决定拦截事件，或者拥有子View成功处理事件，正常分发 if (intercepted || mFirstTouchTarget != null) &#123; ev.setTargetAccessibilityFocus(false); &#125; ... //不拦截事件 final int childrenCount = mChildrenCount; if (newTouchTarget == null &amp;&amp; childrenCount != 0) &#123; final float x = ev.getX(actionIndex); final float y = ev.getY(actionIndex); // Find a child that can receive the event. // Scan children from front to back. final ArrayList&lt;View&gt; preorderedList = buildTouchDispatchChildList(); final boolean customOrder = preorderedList == null &amp;&amp; isChildrenDrawingOrderEnabled(); final View[] children = mChildren; //遍历所有子元素，找到子元素是否能够接收到点击事件 for (int i = childrenCount - 1; i &gt;= 0; i--) &#123; final int childIndex = getAndVerifyPreorderedIndex( childrenCount, i, customOrder); final View child = getAndVerifyPreorderedView( preorderedList, children, childIndex); if (childWithAccessibilityFocus != null) &#123; if (childWithAccessibilityFocus != child) &#123; continue; &#125; childWithAccessibilityFocus = null; i = childrenCount - 1; &#125; //判断条件：是否能够播放动画，落点是否在View内 if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) &#123; ev.setTargetAccessibilityFocus(false); continue; &#125; newTouchTarget = getTouchTarget(child); if (newTouchTarget != null) &#123; newTouchTarget.pointerIdBits |= idBitsToAssign; break; &#125; resetCancelNextUpFlag(child); if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) &#123; // Child wants to receive touch within its bounds. mLastTouchDownTime = ev.getDownTime(); if (preorderedList != null) &#123; // childIndex points into presorted list, find original index for (int j = 0; j &lt; childrenCount; j++) &#123; if (children[childIndex] == mChildren[j]) &#123; mLastTouchDownIndex = j; break; &#125; &#125; &#125; else &#123; mLastTouchDownIndex = childIndex; &#125; mLastTouchDownX = ev.getX(); mLastTouchDownY = ev.getY(); //如果子元素的diapatchTouchEvent返回ture,mFirstTouchTarget会被赋值，且跳出循环 newTouchTarget = addTouchTarget(child, idBitsToAssign); alreadyDispatchedToNewTouchTarget = true; break; &#125; // The accessibility focus didn&apos;t handle the event, so clear // the flag and do a normal dispatch to all children. ev.setTargetAccessibilityFocus(false); &#125; if (preorderedList != null) preorderedList.clear(); &#125; if (newTouchTarget == null &amp;&amp; mFirstTouchTarget != null) &#123; // Did not find a child to receive the event. // Assign the pointer to the least recently added target. newTouchTarget = mFirstTouchTarget; while (newTouchTarget.next != null) &#123; newTouchTarget = newTouchTarget.next; &#125; newTouchTarget.pointerIdBits |= idBitsToAssign; &#125; &#125; &#125; &#125; 源码解读：当事件传递到ViewGroup的dispatchTouchEvent时。 ViewGroup先会通过①是否是down事件②标志位mFirstTouchEvent是否为空判断是否拦截事件。 mFirstTouchEvent通过后续源码可知，当子元素处理成功时，mFirstTouchEvent会被复制并指向子View 验证了结论3 【某个View一旦决定拦截，那么这一个事件序列只能被他处理，且它的onIntercepeTouchEvent不会被调用】，因为如果处理了down事件，那么mFirstTouchEvent就会一直是null，所以move，up事件就不会在调用onIntercepeTouchEvent了 验证了结论11【事件传递过程是由外向内的，即事件总是先传递给父元素然后在由父元素分发给子View。通过requestDisallowInterceptTouchEvent方法可以在子元素中干预父元素的事件分发过程，但ACTIVITY_DOWN事件除外。】 及时被干预了，一旦是down事件，那么就会重置该标记位。 不拦截时，会遍历所有的子View,判断①子View是否能够播放动画，②落点是否View区间内。 当子View为null时， handled = super.dispatchTouchEvent(event),自身当做普通视图，调用View的dispatchTouchEvent，验证了结论4【某个View一旦开始处理事件，如果它在onTouchEvent中不进行对ACTIVITY_DOWN事件消耗，那么同一个事件序列的其他事件都不会交给他完成】 当子View不为null时， handled = child.dispatchTouchEvent(event),调用子View的dispatchTouchEvent View对点击事件的分发过程。带着俩个问题去看源码1.当给Button设置了OnTouchListener并重写了onTouch，方法返回值为true，为何onClice方法会失效？2.什么情况下setClickable会失效？ 1234567891011121314151617181920212223public boolean dispatchTouchEvent(MotionEvent event) &#123; ... if (onFilterTouchEventForSecurity(event)) &#123; if ((mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; handleScrollBarDragging(event)) &#123; result = true; &#125; //noinspection SimplifiableIfStatement ListenerInfo li = mListenerInfo; //判断有没有设置OnTouchListener if (li != null &amp;&amp; li.mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; li.mOnTouchListener.onTouch(this, event)) &#123; result = true; &#125; //result为false时调用自己的onTouchEvent if (!result &amp;&amp; onTouchEvent(event)) &#123; result = true; &#125; &#125; ... return result; &#125; View首先会判断有没有设置OnTouchListener(判断是否遮罩等省略)，如果设置了OnTouchListener且onTouch返回值为true的话，onTouchEvent不会被调用。那接下来看下onTouchEvent的代码 12345678910111213141516171819202122232425262728293031323334353637public boolean onTouchEvent(MotionEvent event) &#123; ... if (clickable || (viewFlags &amp; TOOLTIP) == TOOLTIP) &#123; switch (action) &#123; case MotionEvent.ACTION_UP: ... if (!focusTaken) &#123; // Use a Runnable and post this rather than calling // performClick directly. This lets other visual state // of the view update before click actions start. if (mPerformClick == null) &#123; mPerformClick = new PerformClick(); &#125; if (!post(mPerformClick)) &#123; performClickInternal(); &#125; &#125; &#125; break; case MotionEvent.ACTION_DOWN: ... break; case MotionEvent.ACTION_CANCEL: ... break; case MotionEvent.ACTION_MOVE: ... return true; &#125; return false; &#125; 当ACTIVITY_UP时，会调用PerformClick方法 12345678910111213public boolean performClick() &#123; ... if (li != null &amp;&amp; li.mOnClickListener != null) &#123; playSoundEffect(SoundEffectConstants.CLICK); li.mOnClickListener.onClick(this); result = true; &#125; else &#123; result = false; &#125; ... return result; &#125; 如果View设置了onClickListener，那么就会调用他的onclick方法所以优先级为：onTouchListener&gt;onTouchEvent&gt;onClickListener,问题1，设置了onTouchListener且返回true,那么就不会走onTouchEvent，更不会调用onclick 123456public void setOnClickListener(@Nullable OnClickListener l) &#123; if (!isClickable()) &#123; setClickable(true); &#125; getListenerInfo().mOnClickListener = l; &#125; 问题2的答案，如果先设置了Button的setClickable为false，然后又给其添加点击事件，那么会重新设置它的setClickable为true View的滑动冲突解决View的滑动冲突有固定的套路，毕竟滑动冲突无非以下几种 滑动冲突常见场景 外部滑动和内部滑动方向不一致 常见场景：scrollView+Fragement(ListView)； 外部滑动和内部滑动方向一致 scrollView+ListView 兼容以上 滑动冲突处理准则总得来说：拦截 左右上下滑动不一致时：通过判断滑动方向来确定谁拦截谁 根据业务需求来判断谁拦截谁 同上 滑动冲突解决方式 外部拦截法（常用/简单） 即通过父容器去拦截。重写父容器的onInterceptTouchEvent进行相应拦截 ACTIVITY_DOWN不能拦截，否则事件无法向下分发ACTIVITY_MOVE根据业务状态决定是否拦截ACTIVITY_UP必须返回false 内部拦截法 即父容器不拦截任何事件，子元素需要时消耗，不需要时交给父容器。需要配合requestDisallowInterceptTouchEvent来强制转换 123if(父容器需要)&#123; parent.requestDisallowInterceptTouchEvent(false);&#125; 该标记位不能作用与ACTIVITY_DOWN,因为会重置。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android开发艺术探索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[艺术探索02-IPC机制]]></title>
    <url>%2F2020%2F06%2F08%2F%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A202-IPC%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[Android开发艺术探索阅读梳理第一章节：IPC机制 IPC机制什么是IPC（Inter-Process-Communication）IPC为进程间通信或者跨进程通信，也就是说俩个进程之间进行数据交换的过程。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android开发艺术探索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android开发艺术探索01-Activity的生命周期和启动模式]]></title>
    <url>%2F2020%2F02%2F06%2F%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A201-Activity%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Android开发艺术探索阅读梳理第一章节：Activity的生命周期和启动模式 Activity生命周期梳理典型情况下的Activity的生命周期正常情况下Activity都会经历以下生命周期 onCreate：表示Activity正在被创建，可做初始化操作 onStart：表示Activity正在被启动，此时这个Activity已经可见了，但是还没有出现在前台，无法交互，无法被看到 onRestart：表示Activity正在重新启动，Activity从不可见变为可见时会被调用，一般用户操作导致。 onPause：表示Activity正在停止，正常情况下会紧接着调用onStop。可以存储一些数据或暂停动画等操作，但不能耗时间。不然会时间太长，影响到Activity的onRestart onStop：表示Activity即将停止，可做一些回收操作，但不可耗时 onDestroy：表示Activity即将被销毁，生命周期内的最后一个回调，可做回收和资源释放。 具体切换换过程如下图： 一些情况 当用户打开新的Activity或切换桌面时候，回调如下:onPause-onStop，但如果新的Activity采用了透明主题，那么当前Android不会回调onStop 由A打开B，A的onPause要先于B的onResume执行 异常情况下的Activity的生命周期资源相关的系统配置发生改变导致Activity被杀死并重新创建简单来讲就是当手机方向或系统文字等发生改变时，图片等资源需重新配置其生命周期如下所示： Activity被销毁时，onPause，onStop，onDestroy 均会被调用 因为是异常情况，系统会调用onSaveInstanceState 来保存当前Activity的状态。 onSaveInstanceState方法在onStop之前，onPause之前或之后 当Activity重建后，系统会调用onRestoreInstanceState，并且把销毁时onSaveInstanceState方法保存在Bundle对象作为参数传递给OnRestoreInstanceState和onCreate方法。 onRestoreInstanceState方法调用在onStart之后 onRestoreInstanceState和onCreate都可以取值，onCreate需要判空，官方推荐onRestoreInstanceState。 系统正常销毁不会调用onSaveInstanceState方法 保存和回复流程：使用的是委托思想，Activity被异常销毁后，Activity-window-顶级容器-通知子元素 资源内存不足导致优先级低的Activity被杀死Activity优先级由高到低前台Activity-可交互非前台Activity-可看见不可交互后台Activity configChangesActivity异常情况下被杀死会重建，那怎么可以不进行重建呢？我们可以给Activity指定configChanges属性，比如屏幕旋转后不想重建：configChanges=”orientation” 一般我们常用的属性有： locale 设备本地位置发生变化，一般指切换语言 orientation 屏幕方向发生变化 keyboardHidden 键盘的可访问性发生了变化，比如用户调出了键盘 值得注意的属性 screenSize 当屏幕的尺寸信息发生变化时，当旋转设备后，屏幕尺寸发生变化（屏幕大小） smalllestScreenSize 设备的物理尺寸发生变化时（比如接了外部显示屏） 以上俩个都与编译选项有关 minSdkVersion和targetSdkVersion,低于13时不会重启，高于13会 Activity的启动模式Activity的LaunchMode默认情况下 我们多次启动同一个Activity的时候系统会创建多个实例并把他们保存的任务栈当中，当我们按返回键，这些Activity会一一回退，遵循后进先出的原则。但多次重复的创建过于浪费资源，于是有了以下的启动模式。 standard 标准模式也就是系统的默认模式，每次启动都会重新创建一个新的实例并将其入栈（A启动B，B入栈A所在的任务栈） 不可用ApplicationContext启动standard模式的Activity，因为非Activity类型的Context并没有任务栈。 如果想启动，那么就必须给该Activity设置FLAG_ACTIVITY_NEW_TASK标记位，为它创建一个新的任务栈，这实际上是以singleTask模式启动的 singleTop 栈顶复用模式如果该Activity位于任务栈的栈顶，那么不会被重新创建，同时会走该Activity的onNewIntent方法。 singleTask 栈内复用模式是一种单实例模式，只要该Activity在任务栈中那么就不会重新创建。若站内情况ADBC 如果启动D且D为singleTask模式，那么D以上的Activity都会被顶出栈，此时站内情况AD singleInstance 单实例模式加强singleTask模式，除了拥有singleTask的特性外，还加强了一点，拥有此模式的Activity只能单独存在于栈中 上面提到要在某个栈中找某个Activity，那么Activity和任务栈的的关联是什么？ TaskAffinity 任务相关性，一般是该应用的包名。当然我们可以为其只定TaskAffinity 不可和应用包名相同。 TaskAffinity属性主要是和singleTask启动模式或者allowTaskReparenting属性配对使用。其他情况没有意义。 Activity的FlagsActivity的标记位很多。作用也很多，比如指定Activity的启动模式或运行状态。但一般不需为其指定，熟悉常用的即可 FLAG_ACTIVITY_NEW_TASK为Activity指定singleTask启动模式 FLAG_ACTIVITY_SINGLE_TOP为Activity指定singleTop启动模式 FLAG_ACTIVITY_CLEAR_TOP具有该标志位的Activity，当它启动时，任务栈中在他上方的Activity全部出栈、一般是和singleTask同时使用（singleTask默认有该标志位效果），如果搭配的是默认模式standard，那么连同它在内，所有Activity都出栈，然后创建新的Activity实例安排入栈。 FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS具有该标志位的Activity不会出现在历史Activity的列表中，如果不想用户通过实例列表返回该Activity，就可用该标志位，等同于在XML中的Activity属性：android:excludeFromRecents=”true” (粗略理解在多任务管理器中无法找到) Activity隐式启动我们知道Activity启动分为显示调用和隐式调用。显示就不说了，大家平时都在用。隐式可能会有人有点懵逼，除了简单的拨打电话，几乎没怎么用过，至于拨打电话的代码。。要写吐了对吧。 1startActivity(new Intent(Intent.ACTION_DIAL, Uri.parse(&quot;tel:&quot; + phone))); 写是会写，但为什么要这样写呢。我们一步一步来看。 1234Intent intent=new Intent();//创建意图intent.setAction(Intent.ACTION_CALL);//设置动作：打电话intent.setData(Uri.parse(&quot;tel:&quot;+110);//打给谁startActivity(intent) setAction；setData，我们知道有set的地方，那必会有获取的地方。而所设置的匹配规则，肯定有地方已经写死了的。 我们在上层源码中的清单文件中找到OutgoingCallBroadcaster【源码位置：packages/services/Telephony/src/com/android/phone/OutgoingCallBroadcaster.java】 1234567891011121314151617181920212223242526272829&lt;activity android:name="OutgoingCallBroadcaster" android:permission="android.permission.CALL_PHONE" android:theme="@android:style/Theme.NoDisplay" android:configChanges="orientation|keyboardHidden"&gt; &lt;!-- CALL action intent filters, for the various ways of initiating an outgoing call. --&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.CALL" /&gt; &lt;category android:name="android.intent.category.DEFAULT" /&gt; &lt;data android:scheme="tel" /&gt; &lt;/intent-filter&gt; &lt;intent-filter android:icon="@drawable/ic_launcher_sip_call"&gt; &lt;action android:name="android.intent.action.CALL" /&gt; &lt;category android:name="android.intent.category.DEFAULT" /&gt; &lt;data android:scheme="sip" /&gt; &lt;/intent-filter&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.CALL" /&gt; &lt;category android:name="android.intent.category.DEFAULT" /&gt; &lt;data android:scheme="voicemail" /&gt; &lt;/intent-filter&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.CALL" /&gt; &lt;category android:name="android.intent.category.DEFAULT" /&gt; &lt;data android:mimeType="vnd.android.cursor.item/phone" /&gt; &lt;data android:mimeType="vnd.android.cursor.item/phone_v2" /&gt; &lt;data android:mimeType="vnd.android.cursor.item/person" /&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 可以看到许多intent-filter（意图过滤器），其中 action android:name=”android.intent.action.CALL” data android:scheme=”tel” 这不就是我们刚才所设的么。从上面清单文件可以看出intent-filter可有多个，对应的不同的操作方式，只要匹配一个，就可调起拨打电话。也可以看到intent-filter意图过滤器中过滤的信息有action data category。每一个过滤信息都有对应的规则 action action在intent-filter可以设置多条 intent中必须指定action且只能有一条，否则匹配失败 区分大小写 intent-filter中的action和intent中的action是多对一关系，只要满足一条就会匹配成功 category category在intent-filter中可以设置多条 category在intent中也可以设置多条 intent中可以不设置category，系统会默认设置上default，此时intent-filter中必须设置default。即，只要intent中设置了的category（默认添加也算），那么intent-filter中也必须要设置，且数量内容必须保持同步 date的匹配规则和action类似。只要intent设置了，intent-filter中就必须同步要有。先来看下data的结构 12345678&lt;data android:host="string" android:mimeType="string" android:path="string" android:pathPattern="string" android:pathPrefix="string" android:port="string" android:scheme="string"/&gt; data由俩部分组成，mimeType和URI，mimeType指的是媒体类型，这个我们选择图片和视频时经常用到，URI比较复杂。结构如下 1&lt;scheme&gt;://&lt;host&gt;:&lt;port&gt;/[&lt;path&gt;|&lt;pathPrefix&gt;|&lt;pathPattern&gt;] 难以理解的样子，看下具体例子 12http://www.baidu.com:80/search/infohttp://localhost:4000/2020/02/06/XXXX 没错，就是我们日常可以看到的东西，讲下具体含义 scheme:URI模式，比如http，file，content等。如果URI没有指定scheme，那么URI是无效的Host:URI的主机名，比如www.baidu.com，如果没有指定Host，那么URI是无效的Port:URI中端口号，比如80，只有scheme和host都指定了。Port才是有效的Path:完整路径信息PathPrefix:路径的前缀信息PathPattern:完整路径信息，可包含通配符。总结： data intent-filter中可以设置多个data intent只能设置一个data intent-filter指定了data，intent就要必须指定其中一个data setType和setData会互相覆盖，所以想要指定完整的data就必须要调用setDataAndType 自定义一个隐式启动新建俩个项目StartDemo(启动)，GetStartDemo(被启动)StartDemo中写三个按钮，跳转GetStartDemo中的三个页面 123456789101112131415161718192021222324252627@Override public void onClick(View v) &#123; Intent intent =null; switch (v.getId())&#123; case R.id.tv_main: intent = new Intent(); intent.setAction("com.dreamboat.startdemo"); intent.setData(Uri.parse("http://www.baidu.com:6666")); startActivity(intent); break; case R.id.tv_first: intent = new Intent(); intent.setAction("com.dreamboat.startdemo"); intent.setData(Uri.parse("http://www.baidu.com:6666/first?message=comefirstactivity")); startActivity(intent); break; case R.id.tv_second: intent = new Intent(); intent.setAction("com.dreamboat.startdemo"); intent.setData(Uri.parse("http://www.baidu.com:6666/second?message=comesecondactivity")); startActivity(intent); break; default: break; &#125; &#125; GetStartDemo的清单文件中匹配对应的intent-filter 12345678&lt;intent-filter&gt; &lt;action android:name="com.dreamboat.startdemo"/&gt; &lt;category android:name="android.intent.category.DEFAULT"/&gt; &lt;data android:host="www.baidu.com" android:port="6666" android:scheme="http"/&gt; &lt;/intent-filter&gt; 主页面中判断跳转 12345678910111213141516Uri data = getIntent().getData(); if (data != null)&#123; String path = data.getPath(); String message = data.getQueryParameter("message"); if ("/first".equals(path))&#123; Intent intent=new Intent(this,FirstActivity.class); intent.putExtra("message",message); startActivity(intent); finish(); &#125;else if ("/second".equals(path))&#123; Intent intent=new Intent(this,SecondActivity.class); intent.putExtra("message",message); startActivity(intent); finish(); &#125; &#125; 效果如下 问横竖屏切换时候Activity的生命周期清单文件中不设置Activity的activity:configChanges时。切屏会重新回调每个生命周期，切横屏时会执行一次，切竖屏时会执行俩次。设置Activity的activity:configChanges=”orientation”时，切横竖屏走一次生命周期。设置Activity的activity:configChanges=”orintation|keyboardHidden”时，切屏不会重新调用各个生命周期，只会走onConfigurationChanged方法。切横屏时走一次onConfigurationChanged方法，切竖屏时走俩次。 ActivityA跳转ActivityB然后B按back返回A，各自的生命周期顺序，A不透明B透明。ActivityA跳转到ActivityB： 1234Activity A：onPauseActivity B：onCreateActivity B：onStartActivity B：onResume ActivityB返回ActivityA： 1234Activity B：onPauseActivity A：onResumeActivity B：onStopActivity B：onDestroy Android中跨进程通讯的几种方式1, 意图： 12Intent callIntent = new Intent(Intent.ACTION_CALL,Uri.parse("tel:12345678");startActivity(callIntent); 2,Content Provider3，广播4，AIDL服务 显示Intent与隐式Intent的区别对明确指出了目标组件名称的Intent，我们称之为“显式Intent”对于没有明确指出目标组件名称的Intent，则称之为“隐式 Intent”。对于隐式意图，在定义Activity时，指定一个intent-filter，当一个隐式意图对象被一个意图过滤器进行匹配时，将有三个方面会被参考到： 动作(Action) 多对1 类别(Category) 多对多 数据(Data ) 多对1 android的启动模式 到底在什么时候用 standard 普通activity singleTop 适合接收通知启动的内容显示页面 比如推送页面 自己跳转自己的页面 singleTask 适合程序开始的activity singleInstance 只做一件事情，无后续操作]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android开发艺术探索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[07Java复习-文件,IO流]]></title>
    <url>%2F2019%2F11%2F20%2F07Java%E5%A4%8D%E4%B9%A0-%E6%96%87%E4%BB%B6-IO%E6%B5%81%2F</url>
    <content type="text"><![CDATA[I/O概述 I/O:Input Output 输入输出]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[06Java复习--集合]]></title>
    <url>%2F2019%2F11%2F18%2F06Java%E5%A4%8D%E4%B9%A0-%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[参考资料： Java核心技术 卷一 Collection接口 概述 List下 有ArrayList,Vector,LinkedList; Set下 有HashSet,LinkedHashSet,TreeSet; Collection下还有个Queue接口，有ProorityQueue类 总结List 有序，可重复 ArrayList 底层数据结构是数组 特点：查询快，增删慢，线程不安全。 Vector 底层数数据结构是数组， 特点：线程安全，相比ArrayList慢，不考虑线程是否安全情况下被ArrayList取代 LinkedList 底层数据结构是链表（双向循环链表） 特点：增删快，查询慢，线程不安全 Set 无序，唯一 HashSet 底层数据结构是哈希表（无序，唯一） 如何保证元素唯一性：依赖hashCode()和equals() LinkedHashSet 底层数据结构是链表和哈希表（FIFO（先入先出）插入有序，唯一） 如何保证元素唯一性：哈希表 如何保证元素有序：链表 TreeSet 底层数据结构是红黑树（有序，唯一） 如何保证元素唯一性：根据比较的返回值是否为0来决定 如何保证元素的有序：自然排序，比较器排序 如何选择Colletction下接口 Map接口map接口不继承与Colletcion 是一个独立接口 它提供了一组键值的映射，其中存储的每一个对象都有一个相应的关键字（key）,关键字决定了对象在Map中的存储位置，关键字是唯一的。 概述 Map下几个重要的实现类：HashMap，TreeMap,HashTable等 HashMap: 实现原理：散列 键值对，key不能重复，value可以重复； key的实现就是HashSet； 允许null的键或值（键最多一条）； 线程不安全，想要安全可以用Collections的synchronizedMap方法使得HashMap安全 HashTable:线程安全，但不许null的键或值 TreeMap:对key排好序的Map;key就是TreeSet，value对应每个key，key要实现Comparable接口或TreeMap有自己的构造器 LinkedHashMap:此实现与HashMap的不同之处在于：HashMap维护着一个运行与所有条目的双重链接列表，存储的数据是有序的。Map集合比较 HashMao的存入顺序和输出顺序无关 LinkedHashMap 保留了键值对的存入顺序 TreeMap 是对Map中的元素进行排序，是根据key进行排序，所以，key中存放的对象必须实现Comparable接口 总结与面试主要特性ArrayList:元素单个，效率高，多用于查询Vector:元素单个，线程安全，多用于查询LinkedList:元素单个，多用于插入删除HashMap:元素成对，元素可为空HashTable:元素成对，线程安全，元素不可为空 HashMap和HashTable的区别 相同点 都是Java的集合类，都可以存储Java对象 不同点 HashTable是基于陈旧的Dictionary类，HashMap是Java1.2引进的Map接口的一个实现 HashTable 是同步的，HashMap是异步的。因此HashMap中的对象不是线程安全的 HashMap可以放入空值，HashTable不可以放入空值 ArrayList和Vector的区别 相同点 都是Java的集合类，都用来存放Java对象，底部数据结构都是数组实现 不同点 Vector是同步的，线程安全，ArrayList是异步的，线程不安全。 都是数组实现，但在缺省的情况下，Vector自增一倍，ArrayList自增50% ArrayList和LinkedList的区别 ArrayList底层数据结构是动态数组，LinkedList是链表 对于随机访问get和set，ArrayList优于LinkedList，因为后者要移动指针 对于新增和删除，LinkedList优于ArrayList。不过要看数据量，针对单条，ArrayList占优，批量LinkedList占优。 HashMap与TreeMap区别 HaspMap通过hashcode对其内容进行快速查找，TheeMap中所有元素都保持着某种固定的顺序。如果你需要得到一个有序的结果应该使用TreeMap 在Map中插入删除和定位元素，HashMap是最好的选择，但如果要使用自然顺序，或自定义顺序遍历键，TreeMap更好。 使用HashMap要求添加的键类明确定义了hashcode（）和equals（）的实现。 俩个map中的元素一样，但顺序不一样，会导致hashcode（）不一样。 性能和复杂度之后看过《数据结构》后会单独整理成篇]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[05Java复习--类与对象]]></title>
    <url>%2F2019%2F11%2F14%2F05Java%E5%A4%8D%E4%B9%A0-%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[参考资料： Java核心技术 卷一 面向对象概述 通过操作对象来达到用户需求 就说吃饭吧。饿了要吃东西，自己做饭的话，需要去买菜，洗菜，淘米，烹饪。这个是面向过程。面向对象的话，就是：媳妇，饿了，要吃排骨，你去做吧。媳妇，就是你对象（咦。。。）在Java里，我们就是操作一个个对象去完成各种需求的。 三大特性封装概述封装就是隐藏对象的属性和实现细节，对外公开接口，控制在程序中属性的读和修改的访问级别。将抽象得到的数据和行为相结合，形成一个整体（类） 这样，只能通过规定的方法来访问数据，隐藏了实现细节，提高了程序的安全性和可维护性 举例1234567891011121314public class OOPTest1 &#123; public String name; //公有的 protected String money; //受保护的 int height; //默认的 private int age; //私有的 public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; 无法直接获取age 继承概述继承就是子类继承父类的特征和行为，使得子类对象具有父类的实例域和方法，或类从父类继承方法，使得子类具有父类相同的行为 构造方法和private修饰的不能继承 举例 son继承father的吃饭和说话，还可重写 Android中常用的base类的书写 多态概述同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。也就是在编写程序时，并不能够确定引用变量所指向的具体类型和某个方法。只有当其运行期间才能够确定。 这样，不用修改程序代码，就可以让引用变量绑定到不同的类实现上，从而导致改引用调用的具体方法随之改变，让程序可以选择多个运行状态。这就是多态性 举个列子比如你去面试。桌子前，坐着3个面试官。开始面试前，你只能知道他们是该公司工作人员，并不能晓得他们具体的职位。只有当开始面试，他们开始自我介绍，或者问你问题时候，你才能知道，哦，这个问Java的是Java面试官，这个问Android的是Android面试官，这个问你理想的，是HR。。。 我们可以描述如下 工作人员 a= Java面试官 工作人员 b= Android面试官 工作人员 c= HR 这里所表现的就是多态。Java面试官等都是工作人员的子类。我们只有开始面试后，才能晓得他们具体的工种。通过工作人员一个父类就能够引用不同的子类。 这里需要明白一个概念：向上转型 继续面试的例子。工作人员（Work）是父类，Java面试官（Java），Android面试官（Android），HR（HR）是子类。我们定义如下： Java a=new Java(); 这个很好理解。就是直接new了一个Java面试官的对象。 Work a=new Java();这个呢？ 我们可以这样理解,我们定义了一个Wrok类型的a,他指向Java对象实例。由于Java是继承与Work的，所以Java自动向上转型为Work，所以a是可以指向Java实例对象的。这样我们定义的Java除了可以引用父类Work的共性外，还可以使用子类所扩展的功能。 但向上转型有一些缺陷，那就是它必定会导致一些方法和属性的丢失，我们不能获取到它。所以，父类类型的引用可以调用父类总定义的所有属性和方法，对于只存在与子类中的方法和属性，就无法获取到了。 1234567891011121314151617181920212223242526272829303132333435363738public class OOPTest &#123; public static void main(String[] args) &#123; Work a = new Java(); a.say(); &#125;&#125;class Work &#123; public void say() &#123; System.out.println(&quot;我为公司工作&quot;); work(); &#125; public void work() &#123; System.out.println(&quot;我工作，公司给我工资&quot;); &#125;&#125;class Java extends Work &#123; /** * 子类重载父类方法 * 父类中不存在该方法，向上转型后无法调取改方法 * @param a */ public void say(String a) &#123; System.out.println(&quot;我为公司写Java&quot;); work(); &#125; /** * 子类重写父类方法 * 调取时必定是调取该方法 */ public void work() &#123; System.out.println(&quot;我写Java，公司给我工资&quot;); &#125;&#125; 输出：我为公司工作/我写Java，公司给我工资 通过输出我们可以得知，a.say首先是运行父类Work中的say()方法，然后在运行子类Java中的work()方法。 分析：在这个程序中，子类Java重载了父类的say()，重写了work();而重载后的say(String a)和父类的say()不是一个方法，向上转型后会丢失改方法。而重写了work(),指向Java的Work会调用Java中的work(); 总结：指向子类的父类引用，由于向上转型了，它只能访问父类中存在的方法和属性，对于不存在的，是无法调用使用的，就算是重载该方法，也不可以。若子类重写了父类中的某些方法，在调用时，必定是调用的子类重写后的该方法（动态链接，动态调用）。 当超类对象引用变量 引用子类对象时，被引用对象的类型（不是引用变量的类型）决定了调用谁的成员方法。但是这个被调用的方法必须是在超类中定义过的。也就是说，被子类覆盖的方法。继承链中对象方法调用的优先级：this.show(O),super.show(O),this.show((super)0),super.show((super)O) 成员变量，静态方法：看左边 非静态方法：编译看左边，运行看右边 五大原则高内聚低耦合 单一职责（SRP）一个类只完成它应该完成的职责，不能越俎代庖，不能成为无所不能的上帝类。 开放封闭原则(OCP)软件实体应当对外扩展开放，对内修改闭合。也就是说，不能再修改一个类的前提下扩展这个类。 里式替换原则(LSP)子类型必须能够替换他们的基类型。也就是说，使用基类引用的地方必须能够使用继承类的对象，而不必知道它。 依赖倒置原则（DIP）高层模块不应该依赖底层模块。俩者都应该依赖其抽象。（面向接口编程） 接口分离原则（ISP）一个接口或者类应该尽可能少的行为。要明确，易理解，可复用。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[04Java复习--数组]]></title>
    <url>%2F2019%2F09%2F11%2F04Java%E5%A4%8D%E4%B9%A0--%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[今天最好的表现是明天最低的要求 参考资料：Java核心技术 卷一 数组基本概念数组是一种数据结构，用来存储同一类型的集合。通过下标，可以访问数组中的每一个值。 为什么要使用数组1，单一值类型变量有时难以满足应用程序的设计要求比如你要定义100个整型变量，那么如果不使用数组，可能需要： 1int i1,i2,i3....i100; 如果要输出这100个变量，那。。 2，可以自动给数组中的元素从0开始编号，方便操作这些元素 数组的初始化 动态初始化 声明并开辟数组 数据类型[] 数组名称 = new 数据类型[长度] （常用） 数据类型 数组名称[] = new 数据类型[长度] 分步声明开辟数组 数据类型[] 数组名称=null 数据名称 = new 数据类型[长度] 1234567891011121314151617181920212223public class Main &#123; public static void main(String[] args) &#123; //动态声明开辟 int[] a = new int[2]; a[0] = 1; a[1] = 2; for (int i = 0; i &lt; a.length; i++) &#123; System.out.println(a[i]); &#125; int b[] = new int[2]; b[0] = 3; b[1] = 4; for (int x : b) &#123; System.out.println(x); &#125; //动态声明开辟-分步 int[] c = null; c = new int[2]; c[0] = 5; c[1] = 6; System.out.println(Arrays.toString(c)); &#125;&#125; 静态初始化 数据类型 数组名称 =new 数据类型{值1，值2} 数据类型 数组名称={值1，值2} 不论怎么初始化，一定是声明+开辟空间，因为数组属于引用类型。不开辟空间的话，无法在堆内存中找到，会出现NullPointerException异常 数组的排序和最值获取最值12345678910111213141516171819202122public class Main &#123; public static void main(String[] args) &#123; //获取最大值最小值 int[] a = &#123;22, 55, 34, 78, 203, 3, 5&#125;; //声明最大最小值 int max = a[0]; int min = a[0]; //比较记录 for (int i = 0; i &lt; a.length; i++) &#123; if (a[i] &gt; max) &#123; max = a[i]; &#125; &#125; for (int i = 0; i &lt; a.length; i++) &#123; if (a[i] &lt; min) &#123; min = a[i]; &#125; &#125; System.out.println(&quot;最大值=&quot; + max); System.out.println(&quot;最小值=&quot; + min); &#125;&#125; Arrays.sort(）12345678910111213141516171819202122232425262728public class Main &#123; public static void main(String[] args) &#123; Integer[] a = &#123;22, 55, 34, 78, 203, 3, 5&#125;; //优化的快速排序方法（串行排序）Build completed successfully in 2 s 722 ms Arrays.sort(a); System.out.println(Arrays.toString(a)); //优化的快速排序方法（并行排序）性能和串行比较高 Build completed successfully in 2 s 666 ms Arrays.parallelSort(a); System.out.println(Arrays.toString(a)); //从大大小排序 Build completed successfully in 2 s 777 ms Comparator comparator = new MyComparator(); Arrays.sort(a, comparator); System.out.println(Arrays.toString(a)); &#125; static class MyComparator implements Comparator&lt;Integer&gt; &#123; @Override public int compare(Integer o1, Integer o2) &#123; if (o1 &lt; o2) &#123; return 1; &#125; else if (o1 &gt; o2) &#123; return -1; &#125; else &#123; return 0; &#125; &#125; &#125;&#125; 输出结果： 排序回顾完集合后会单独整理一篇排序]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[03Java复习--控制流程]]></title>
    <url>%2F2019%2F08%2F12%2F03Java%E5%A4%8D%E4%B9%A0--%E6%8E%A7%E5%88%B6%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[参考资料：Java核心技术 卷一 与任何程序设计语言一样，Java使用条件语句和循环结构来确定控制流程 块作用域块是指由一对大括号括起来的若干条简单的Java语句,块确定了变量的作用域，不可在嵌套的俩个块中声明同名的变量 1234567public static void mian(String[] str) &#123; int n; &#123; int k; int n;//不可声明，Variable &apos;n&apos; is already defined in the scope &#125; &#125; 条件语句 if if,如果 if(条件){},执行语句一条时，中括号可省略 12345678910public class Main &#123; public static void main(String[] args) &#123; int a=6; if(a&gt;5)&#123; System.out.println(&quot;我比5大&quot;); &#125;else &#123; System.out.println(&quot;我比5小&quot;); &#125; &#125;&#125; 输出结果： 循环while while(条件){输出} 123456789public class Main &#123; public static void main(String[] args) &#123; int a=1; while (a&lt;10)&#123; a++; System.out.println(a); &#125; &#125;&#125; while，一直循环，直到变量a自增到大于10while 语句会首先检测条件，当条件不满足时，代码不会被执行。所以如果需要至少执行一次代码的话，应该把条件放到最后。使用do while do while123456789public class Main &#123; public static void main(String[] args) &#123; int a=1; do&#123; System.out.println(a); a++; &#125;while (a&lt;5); &#125;&#125; 先执行一次代码，在进行判断 确定循环 for根据块的概念，循环有其单独的作用域（{}之内） 1234for (int i = 0; i &lt;10 ; i++) &#123; //执行语句 //第一部分：计数器初始化 第二部分：条件 第三部分如何更新计数器 &#125; 循环嵌套嵌套循环及双层/多层循环进行嵌套 打印一个正方形 123456for (int i = 0; i &lt;10 ; i++) &#123; for (int j = 0; j &lt; 10; j++) &#123; System.out.print(&quot; *&quot;); &#125; System.out.println();//换行 &#125; 打印一个直角三角形 123456for (int i = 1; i &lt;10 ; i++) &#123; for (int j = 0; j &lt; i; j++) &#123; System.out.print(&quot; *&quot;); &#125; System.out.println();//换行 &#125; for each 循环（增强for循环）结构：for(int k:a) 1for(变量类型 变量名：数组名)&#123; 执行语句&#125; for循环是通过循环控制变量，访问数组中不同位置处的元素进行遍历 for-each循环是依次处理数组中的元素，不必为指定下标值分心 下面是一个使用for-each循环寻找数组内元素的例子 1234567891011121314151617public class Main &#123; public static void main(String[] args) &#123; int [] a=new int [10];//新建长度为10的数组 for (int i = 0; i &lt; a.length; i++) &#123;//给数组赋值 a[i]=i; &#125; int b=5; for(int c:a)&#123; if(c==b)&#123; System.out.println(&quot;找到了 c=&quot;+c); &#125;else &#123; System.out.println(&quot;没找到&quot;); &#125; &#125; &#125;&#125; 输出：如果只需找到数组中是否有某个元素，而不返回对应下标，使用for-each循环更加简洁，不易出错。 如果只是单纯想打印数组中的元素,可以使用Arrays.toString(); 多重选择 switch1234567891011switch (表达式) &#123; case 取值1: //char byte short或int的常量表达式 //枚举常量 //Java SE7 开始可用字符串 break; //最终执行 default: break; &#125; 中断控制流程语句goto是拙劣的，Java虽未删除，但依旧没使用它。 但跳出循环还是需要的，使用其他的代替 break12345678public class Main &#123; public static void main(String[] args) &#123; for (int i = 1; i &lt;10 ; i++) &#123; System.out.print(i); break; &#125; &#125;&#125; 输出结果当代码执行循环第一次时，break就执行了，不再进行之后的循环 continue1234567891011public class Main &#123; public static void main(String[] args) &#123; for (int i = 0; i &lt;10 ; i++) &#123; if(i%2==1)&#123; continue; &#125; System.out.println(i); &#125; &#125;&#125; 输出结果 当i % 2 == 1时，程序正常循环，否则终止本次循环，直接开启下次循环]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义StringBuilder和StringBuffer]]></title>
    <url>%2F2019%2F08%2F01%2F%E8%87%AA%E5%AE%9A%E4%B9%89StringBuilder%E5%92%8CStringBuffer%2F</url>
    <content type="text"><![CDATA[根据上篇得出的规律 初始默认长度16或自定义 扩增规律：原有容量*2+2 StingBuilder和StringBuffer都继承与AbstractStringBuilder，且AbstractStringBuilder不可由外部调用。所以首先写一个MyAbstractStringBuilder类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public class MyAbsractStringBuilder &#123; /** * 存储字符的数组 */ char[] value; /** * 记录append操作，添加字符的数量 */ int count; /** * 无参构造 */ MyAbsractStringBuilder() &#123; &#125; /** * @param capacity 为char 数组定义大小 */ MyAbsractStringBuilder(int capacity) &#123; value = new char[capacity]; &#125; public MyAbsractStringBuilder append(String str) &#123; if (str == null) &#123; value = new char[0]; return this; &#125; int len = str.length();//获取新添加字符的长度 ensureCapacityInternal(count + len);//已知新字符的长度，若超出原数组长度，在原有的基础上创建（扩充）一个新的容器（数组） str.getChars(0, len, value, count);//使用string的getchars方法将字符从该字符串复制到value数组中 count += len;//count 长度 return this; &#125; private void ensureCapacityInternal(int needCapacity) &#123; if (needCapacity &gt; value.length) &#123;//现有数组容量不满足 value = Arrays.copyOf(value, newCapacity(needCapacity));//创建新的数组 参数2：新的数组的长度 &#125; &#125; private int newCapacity(int needCapacity) &#123; int newCapacity = (value.length * 2) + 2;//定义新的容量，原有容量*2+2 if (newCapacity &lt; needCapacity) &#123; //如果新容量小于所需容量，新容量=所需容量 newCapacity = needCapacity; &#125; // 数组分配最大大小，超过最大限制可能会导致OutOfMemoryError return newCapacity &gt; Integer.MAX_VALUE - 8 ? newCapacity : Integer.MAX_VALUE - 8; &#125; /** * @return 长度 */ public int length() &#123; return count; &#125; /** * @return 容量 */ public int capacity() &#123; return value.length; &#125; /** * @return 字符串 */ public String toString() &#123; return new String(value, 0, count); &#125;&#125; 定义MyStringBuilder类继承MyAbsractStringBuilder 1234567891011121314151617181920212223242526272829public class MyStringBuilder extends MyAbsractStringBuilder &#123; MyStringBuilder() &#123; super(16); &#125; MyStringBuilder(int capacity) &#123; super(capacity); &#125; @Override public MyAbsractStringBuilder append(String str) &#123; return super.append(str); &#125; @Override public int length() &#123; return super.length(); &#125; @Override public int capacity() &#123; return super.capacity(); &#125; @Override public String toString() &#123; return super.toString(); &#125;&#125; 主函数调用 12345MyStringBuilder myStringBuilder=new MyStringBuilder(); myStringBuilder.append(&quot;myStringBuilder&quot;); LogUtils.e(&quot;myStringBuilder的长度&quot;+myStringBuilder.length()); LogUtils.e(&quot;myStringBuilder的容量&quot;+myStringBuilder.capacity()); LogUtils.e(&quot;---&quot;+myStringBuilder.toString()); log打印 StringBuffer与StringBuilder 不同的是，方法需要加同步锁 123456789101112131415161718192021222324252627282930public class MyStringBuffer extends MyAbsractStringBuilder&#123; MyStringBuffer() &#123; super(16); &#125; MyStringBuffer(int capacity) &#123; super(capacity); &#125; @Override public synchronized MyAbsractStringBuilder append(String str) &#123; return super.append(str); &#125; @Override public synchronized int length() &#123; return super.length(); &#125; @Override public synchronized int capacity() &#123; return super.capacity(); &#125; @Override public synchronized String toString() &#123; return super.toString(); &#125;&#125;]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[02Java复习--Java基本程序设计结构]]></title>
    <url>%2F2019%2F06%2F26%2F02Java%E5%A4%8D%E4%B9%A0--Java%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[参考资料：Java核心技术 卷一 基本的Java设计结构12345678// 公共的 类 类名 public class FirstJava &#123;//公共的 静态的 无返回值 main方法 数组 public static void main (String[] args) &#123; //输出语句 System.out.printIn(&quot;Hello World&quot;); &#125; &#125; 访问修饰符 publish 可以被任何类访问 protected 可以被同一个包中的所有类访问 private 只能被当前类的方法访问 缺省 可以被同一包中的所有类访问 类名 驼峰命名 不能用关键字 其他命名规范 包 最好是域名倒过来，所有字母小写 接口 驼峰命名 不能用关键字 方法或变量 如果是一个单子全部小写 如果是多个单词，从第二个单词开始首字母大写 常量 如果是一个单词，所有字母大写 如果是多个单词，所有的单词大写，用下划线分离每个单词 注释12345单行注释 //多行注释/** * */ 数据类型byte 整型 占一个字节 8位，最大存储数据量是255.存放的数据范围是-128-127之间 封装器类 Byte short 整形 占俩个字节 16位，最大数据存储量是65536^-^,数据范围是-32768-32767之间 封装器类 Short int 整形 占四个字节 32位，最大数据存储容量是2的32次方-1，数据范围是负的2的1次方到正的2的31次 long 整形 占八个字节 64位，最大数据存储容量是2的64次方-1数据范围是负的0的63次方到挣得2的64次方减一 float 浮点型 占四个字节 32位，数据范围在正负3.4E+38F 必须有后缀 f或F double 浮点型 占八个字节 64位 boolean 只有true和false 俩个值 char 16位 存储Unicode码 用单引号复制 变量 每一个变量都有一个类型（type） 变量是可以重复复制的 大小写敏感，不可用Java保留字 建议逐一声明 常量 利用关键字final指示常量 只能被赋值一次 常量名全部大写，多个单词下划线连接 运算符算数运算符 简单的+ - x / % 需注意，整数不可被0整除，浮点数被0整除会得到无穷大或者NaN的结果 赋值运算符 +=;-=;*=;/=;%=; 把左边的和右边的做XX法然后赋值给左边。一般把运算符放在=左边 比较运算符 &lt;;&gt;;==等 返回值true或false 逻辑运算符 &amp; 1234567/** * true &amp; true true * true &amp; false false * false &amp; true false * false &amp; false false * 总结：&amp;符号就是你两边都是true才成立，换句话说，两边只要有一个false，就是false */ | 12345678/** * true | true true * true | false true * false | true true * false | false false * * 总结：只要就一个成立就可以，也就是返回true，只有当两个都是false才会返回false */ ^ 1和|差不多，除了 true^true= false ！ 123非int a=1;!a=2; 返回true &amp;&amp; 1从左到右，只要有false 后面就不执行了 || 1从左到右，只要有true 后面就不执行了 位运算符 &lt;&lt;左移 &gt;&gt;右移 &gt;&gt;&gt;无符号右移 &amp;与运算 |或运算 ^异和运算 ~反码 二进制运算，需懂进制转换 效率（计算机实际上在内存中也是讲数字转换成二进制进行计算） 三元运算符 （条件表达式）? 表达式1（true）：表达式2（false） 字符串 概念上讲 Java字符串就是Unicode字符序列 提取自串 substring 比较 equals String使用字符数组保存,有final修饰符，不可变,可理解为常量，所以线程安全 equals与==的区别前提：在JVM中，内存分为堆内存和栈内存。二者的区别是：当我们创建一个对象时，就会调用对象的构造函数来开辟空间。将对象的数据存储在堆内存中，与此同时，在栈内存中生成对应的引用。当我们后续使用该对象时候，调用的都是栈内存中的引用。 1,==是判断俩个变量或实例是不是指向同一个内存空间，equals是判断俩个变量或实例所指向的内存空间的值是不是相同2，==是指对内存地址进行比较，equals是对字符串内容进行比较3，==指引用是否相同，equals指的是值是否相同 注意：基本数据类型是存储在栈内存中，==比较基本数据类型时比较的是值。 常用String Api int index0f() 如果原字符串中不存在。返回-1 subString 获取子串 trim 去除首尾空白字符 构建字符串StringBuilder 继承自AbstractStringBuilder，使用字符数组保存字符串。可变 未对方法添加同步锁，线程不安全 如果程序不是多线程的，那么StringBuilder效率高于StringBuffer StringBuffer 继承自AbstractStringBuilder，使用字符数组保存字符串。可变 对方法或者对调用的方法加了同步锁，线程安全 capacity()方法容量问题1234567891011121314151617StringBuilder builder=new StringBuilder(); builder.append(&quot;capacity&quot;); LogUtils.e(&quot;capacity的长度&quot;+builder.length()); LogUtils.e(&quot;capacity的容量&quot;+builder.capacity());StringBuilder builder1=new StringBuilder(); builder1.append(&quot;capacity超过16超过16超过16&quot;); LogUtils.e(&quot;capacity超过16的长度&quot;+builder1.length()); LogUtils.e(&quot;capacity超过16的长度的容量&quot;+builder1.capacity()); for (int i = 0; i &lt; 4; i++) &#123; LogUtils.e(&quot;-------------------&quot;+i+&quot;---------------------&quot;); builder1.append(&quot;capacity超过16超过16超过16&quot;); LogUtils.e(&quot;capacity超过16的长度&quot;+builder1.length()); LogUtils.e(&quot;capacity超过16的长度的容量&quot;+builder1.capacity()); &#125; 可以看出，当为缺省构造时，且不超过16时，默认容量为16，超过时在原有的基础上*2+2; 1234StringBuilder builder2=new StringBuilder(10);builder2.append(&quot;capacity&quot;);LogUtils.e(&quot;capacity的长度&quot;+builder2.length()); LogUtils.e(&quot;capacity的容量&quot;+builder2.capacity()); 当为有参构造时，不使用默认长度容量，自定义初始容量。超过16时与缺省构造相同 自定义StringBuilder和StringBuffer]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[01Java复习--基本常识，Java概念]]></title>
    <url>%2F2019%2F05%2F15%2F01Java%E5%A4%8D%E4%B9%A0--%E5%9F%BA%E6%9C%AC%E5%B8%B8%E8%AF%86%EF%BC%8CJava%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[参考资料： Java核心技术 卷一https://blog.csdn.net/simplebam/article/details/65447600 基本常识什么是软件 软件：一系列按照特定组织的计算机数据和指令的集合 常用CDM命令 dir:列出当前目录下的文件及文件夹（ md:创建目录 rd:删除目录 cd:进入指定目录 cd ..:退回到上一级目录 cd\:退回到根目录 del(delete):删除文件 exit:退出dos命令行 cls(clear screen)：清屏 Mac常用命令 cd:进入指定目录 ls:列出当前目录下的所有文件 pwd:显示当前目录路径 mkdir:新建目录 rmdir:删除目录 env: 显示当前所有设置过的环境变量 Java概念什么是Java Java是一门面向对象编程语言，95年sun公司发布。 Java的优点简单性 风格类似于C++,缺摒弃了C++中一些很少用到的特征，比如go to 语句，Java也没有头文件，指针运算等。 Java提供了丰富的类库 面向对象OOP 基本概念 对象 对象是人们要进行研究的任何事物，不仅能表示具体的事物，还能表示抽象的规则、计划或事件 对象的状态和行为 具有相同或相似性质的对象的抽象就是类，因此，对象的抽象是类，类的具体化就是对象，也可以说类的实例是对象。 类具有属性，他是对象的状态的抽象，用数据结构来描述类的属性 类具有操作，他是对象的行为的抽象，用操作名和实现该操作的方法来描述 类的结构 一般：具体结构成为分类结构，也可以说是“或”关系，或者是”is a“关系 整体：不跟结构成为组装结构，他们之间的关系是一种”与“关系，或者是”has a“关系 消息和方法 对象直接进行通信的结构叫做消息 类中操作的实现过程叫做方法。 三大特性 封装：隐藏对象的属性和实现细节，仅对外提供公共访问方式，将变化隔离，便于使用，提高复用性和安全性 继承：提高代码复用性；继承是多态的前提 多态：父类或接口定义的引用变量可以指向子类或具体实现类的实例对象，提高了程序的拓展性。 五大基本原则 单一职责原则（SRP）:类的功能要单一 开放封闭原则（OCP）:一个模块对于拓展是开放的，对于修改是封闭的 里式替换原则（LSP）:子类可以替换父类出现在父类能够出现的任何地方 依赖倒置原则（DIP）:高层次的模块不应该依赖低层次的模块，他们都应该依赖于抽象。抽象不应该依赖于具体实现，具体实现应该依赖于抽象。 接口分离原则（ISP）:设计采用多个特定客户类有关的接口比采用一个通用的接口要好。 总结 面向对象：易维护，易复用，易拓展，低耦合。 面向过程：性能高，耗资源 分布式 Java有一个丰富的例程库，用于处理像HTTP和FTP之类的TCP/IP协议。Java程序可以通过URL打开和访问网络上的对象 健壮性 早期问题检测、运行时检测 Java和C++最大的不同在于Java采用的指针模型可以消除重写内存和损坏数据的可能 安全性 防病毒–运行时堆栈溢出，如蠕虫和病毒常用的攻击手段 防篡改–未经授权不可读写文件，除非有数字签名 存储分配模型–Java没有指针，所有无法得到隐藏起来的内幕，也无法伪造指针去指向存储器。Java编译程序不处理存储安排决策（由Java解释程序决定），所以程序猿不能通过查看声明去猜测类的实际存储安排。 体系结构中立（编译和解释性） Java程序可以在任何实现了Java解释程序和运行系统的系统上运行 可移植性 Java规范中没有“依赖具体实现”的方法 基本数据类型的大小和范围都做了明确的说明 高性能 即时编译 多线程性 Java是第一个支持并发程序设计的主流语言 动态性 Java中的类是根据需要载入的，甚至有些是通过Internet获取的]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java基础</tag>
      </tags>
  </entry>
</search>
