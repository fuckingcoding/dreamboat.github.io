<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[艺术探索03-View的事件体系]]></title>
    <url>%2F2020%2F07%2F14%2F%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A203-View%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[艺术探索02-IPC机制]]></title>
    <url>%2F2020%2F06%2F08%2F%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A202-IPC%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[Android开发艺术探索阅读梳理第一章节：IPC机制 IPC机制什么是IPC（Inter-Process-Communication）IPC为进程间通信或者跨进程通信，也就是说俩个进程之间进行数据交换的过程。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android开发艺术探索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android开发艺术探索01-Activity的生命周期和启动模式]]></title>
    <url>%2F2020%2F02%2F06%2F%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A201-Activity%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Android开发艺术探索阅读梳理第一章节：Activity的生命周期和启动模式 Activity生命周期梳理典型情况下的Activity的生命周期正常情况下Activity都会经历以下生命周期 onCreate：表示Activity正在被创建，可做初始化操作 onStart：表示Activity正在被启动，此时这个Activity已经可见了，但是还没有出现在前台，无法交互，无法被看到 onRestart：表示Activity正在重新启动，Activity从不可见变为可见时会被调用，一般用户操作导致。 onPause：表示Activity正在停止，正常情况下会紧接着调用onStop。可以存储一些数据或暂停动画等操作，但不能耗时间。不然会时间太长，影响到Activity的onRestart onStop：表示Activity即将停止，可做一些回收操作，但不可耗时 onDestroy：表示Activity即将被销毁，生命周期内的最后一个回调，可做回收和资源释放。 具体切换换过程如下图： 一些情况 当用户打开新的Activity或切换桌面时候，回调如下:onPause-onStop，但如果新的Activity采用了透明主题，那么当前Android不会回调onStop 由A打开B，A的onPause要先于B的onResume执行 异常情况下的Activity的生命周期资源相关的系统配置发生改变导致Activity被杀死并重新创建简单来讲就是当手机方向或系统文字等发生改变时，图片等资源需重新配置其生命周期如下所示： Activity被销毁时，onPause，onStop，onDestroy 均会被调用 因为是异常情况，系统会调用onSaveInstanceState 来保存当前Activity的状态。 onSaveInstanceState方法在onStop之前，onPause之前或之后 当Activity重建后，系统会调用onRestoreInstanceState，并且把销毁时onSaveInstanceState方法保存在Bundle对象作为参数传递给OnRestoreInstanceState和onCreate方法。 onRestoreInstanceState方法调用在onStart之后 onRestoreInstanceState和onCreate都可以取值，onCreate需要判空，官方推荐onRestoreInstanceState。 系统正常销毁不会调用onSaveInstanceState方法 保存和回复流程：使用的是委托思想，Activity被异常销毁后，Activity-window-顶级容器-通知子元素 资源内存不足导致优先级低的Activity被杀死Activity优先级由高到低前台Activity-可交互非前台Activity-可看见不可交互后台Activity configChangesActivity异常情况下被杀死会重建，那怎么可以不进行重建呢？我们可以给Activity指定configChanges属性，比如屏幕旋转后不想重建：configChanges=”orientation” 一般我们常用的属性有： locale 设备本地位置发生变化，一般指切换语言 orientation 屏幕方向发生变化 keyboardHidden 键盘的可访问性发生了变化，比如用户调出了键盘 值得注意的属性 screenSize 当屏幕的尺寸信息发生变化时，当旋转设备后，屏幕尺寸发生变化（屏幕大小） smalllestScreenSize 设备的物理尺寸发生变化时（比如接了外部显示屏） 以上俩个都与编译选项有关 minSdkVersion和targetSdkVersion,低于13时不会重启，高于13会 Activity的启动模式Activity的LaunchMode默认情况下 我们多次启动同一个Activity的时候系统会创建多个实例并把他们保存的任务栈当中，当我们按返回键，这些Activity会一一回退，遵循后进先出的原则。但多次重复的创建过于浪费资源，于是有了以下的启动模式。 standard 标准模式也就是系统的默认模式，每次启动都会重新创建一个新的实例并将其入栈（A启动B，B入栈A所在的任务栈） 不可用ApplicationContext启动standard模式的Activity，因为非Activity类型的Context并没有任务栈。 如果想启动，那么就必须给该Activity设置FLAG_ACTIVITY_NEW_TASK标记位，为它创建一个新的任务栈，这实际上是以singleTask模式启动的 singleTop 栈顶复用模式如果该Activity位于任务栈的栈顶，那么不会被重新创建，同时会走该Activity的onNewIntent方法。 singleTask 栈内复用模式是一种单实例模式，只要该Activity在任务栈中那么就不会重新创建。若站内情况ADBC 如果启动D且D为singleTask模式，那么D以上的Activity都会被顶出栈，此时站内情况AD singleInstance 单实例模式加强singleTask模式，除了拥有singleTask的特性外，还加强了一点，拥有此模式的Activity只能单独存在于栈中 上面提到要在某个栈中找某个Activity，那么Activity和任务栈的的关联是什么？ TaskAffinity 任务相关性，一般是该应用的包名。当然我们可以为其只定TaskAffinity 不可和应用包名相同。 TaskAffinity属性主要是和singleTask启动模式或者allowTaskReparenting属性配对使用。其他情况没有意义。 Activity的FlagsActivity的标记位很多。作用也很多，比如指定Activity的启动模式或运行状态。但一般不需为其指定，熟悉常用的即可 FLAG_ACTIVITY_NEW_TASK为Activity指定singleTask启动模式 FLAG_ACTIVITY_SINGLE_TOP为Activity指定singleTop启动模式 FLAG_ACTIVITY_CLEAR_TOP具有该标志位的Activity，当它启动时，任务栈中在他上方的Activity全部出栈、一般是和singleTask同时使用（singleTask默认有该标志位效果），如果搭配的是默认模式standard，那么连同它在内，所有Activity都出栈，然后创建新的Activity实例安排入栈。 FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS具有该标志位的Activity不会出现在历史Activity的列表中，如果不想用户通过实例列表返回该Activity，就可用该标志位，等同于在XML中的Activity属性：android:excludeFromRecents=”true” (粗略理解在多任务管理器中无法找到) Activity隐式启动我们知道Activity启动分为显示调用和隐式调用。显示就不说了，大家平时都在用。隐式可能会有人有点懵逼，除了简单的拨打电话，几乎没怎么用过，至于拨打电话的代码。。要写吐了对吧。 1startActivity(new Intent(Intent.ACTION_DIAL, Uri.parse(&quot;tel:&quot; + phone))); 写是会写，但为什么要这样写呢。我们一步一步来看。 1234Intent intent=new Intent();//创建意图intent.setAction(Intent.ACTION_CALL);//设置动作：打电话intent.setData(Uri.parse(&quot;tel:&quot;+110);//打给谁startActivity(intent) setAction；setData，我们知道有set的地方，那必会有获取的地方。而所设置的匹配规则，肯定有地方已经写死了的。 我们在上层源码中的清单文件中找到OutgoingCallBroadcaster【源码位置：packages/services/Telephony/src/com/android/phone/OutgoingCallBroadcaster.java】 1234567891011121314151617181920212223242526272829&lt;activity android:name="OutgoingCallBroadcaster" android:permission="android.permission.CALL_PHONE" android:theme="@android:style/Theme.NoDisplay" android:configChanges="orientation|keyboardHidden"&gt; &lt;!-- CALL action intent filters, for the various ways of initiating an outgoing call. --&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.CALL" /&gt; &lt;category android:name="android.intent.category.DEFAULT" /&gt; &lt;data android:scheme="tel" /&gt; &lt;/intent-filter&gt; &lt;intent-filter android:icon="@drawable/ic_launcher_sip_call"&gt; &lt;action android:name="android.intent.action.CALL" /&gt; &lt;category android:name="android.intent.category.DEFAULT" /&gt; &lt;data android:scheme="sip" /&gt; &lt;/intent-filter&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.CALL" /&gt; &lt;category android:name="android.intent.category.DEFAULT" /&gt; &lt;data android:scheme="voicemail" /&gt; &lt;/intent-filter&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.CALL" /&gt; &lt;category android:name="android.intent.category.DEFAULT" /&gt; &lt;data android:mimeType="vnd.android.cursor.item/phone" /&gt; &lt;data android:mimeType="vnd.android.cursor.item/phone_v2" /&gt; &lt;data android:mimeType="vnd.android.cursor.item/person" /&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 可以看到许多intent-filter（意图过滤器），其中 action android:name=”android.intent.action.CALL” data android:scheme=”tel” 这不就是我们刚才所设的么。从上面清单文件可以看出intent-filter可有多个，对应的不同的操作方式，只要匹配一个，就可调起拨打电话。也可以看到intent-filter意图过滤器中过滤的信息有action data category。每一个过滤信息都有对应的规则 action action在intent-filter可以设置多条 intent中必须指定action且只能有一条，否则匹配失败 区分大小写 intent-filter中的action和intent中的action是多对一关系，只要满足一条就会匹配成功 category category在intent-filter中可以设置多条 category在intent中也可以设置多条 intent中可以不设置category，系统会默认设置上default，此时intent-filter中必须设置default。即，只要intent中设置了的category（默认添加也算），那么intent-filter中也必须要设置，且数量内容必须保持同步 date的匹配规则和action类似。只要intent设置了，intent-filter中就必须同步要有。先来看下data的结构 12345678&lt;data android:host="string" android:mimeType="string" android:path="string" android:pathPattern="string" android:pathPrefix="string" android:port="string" android:scheme="string"/&gt; data由俩部分组成，mimeType和URI，mimeType指的是媒体类型，这个我们选择图片和视频时经常用到，URI比较复杂。结构如下 1&lt;scheme&gt;://&lt;host&gt;:&lt;port&gt;/[&lt;path&gt;|&lt;pathPrefix&gt;|&lt;pathPattern&gt;] 难以理解的样子，看下具体例子 12http://www.baidu.com:80/search/infohttp://localhost:4000/2020/02/06/XXXX 没错，就是我们日常可以看到的东西，讲下具体含义 scheme:URI模式，比如http，file，content等。如果URI没有指定scheme，那么URI是无效的Host:URI的主机名，比如www.baidu.com，如果没有指定Host，那么URI是无效的Port:URI中端口号，比如80，只有scheme和host都指定了。Port才是有效的Path:完整路径信息PathPrefix:路径的前缀信息PathPattern:完整路径信息，可包含通配符。总结： data intent-filter中可以设置多个data intent只能设置一个data intent-filter指定了data，intent就要必须指定其中一个data setType和setData会互相覆盖，所以想要指定完整的data就必须要调用setDataAndType 自定义一个隐式启动新建俩个项目StartDemo(启动)，GetStartDemo(被启动)StartDemo中写三个按钮，跳转GetStartDemo中的三个页面 123456789101112131415161718192021222324252627@Override public void onClick(View v) &#123; Intent intent =null; switch (v.getId())&#123; case R.id.tv_main: intent = new Intent(); intent.setAction("com.dreamboat.startdemo"); intent.setData(Uri.parse("http://www.baidu.com:6666")); startActivity(intent); break; case R.id.tv_first: intent = new Intent(); intent.setAction("com.dreamboat.startdemo"); intent.setData(Uri.parse("http://www.baidu.com:6666/first?message=comefirstactivity")); startActivity(intent); break; case R.id.tv_second: intent = new Intent(); intent.setAction("com.dreamboat.startdemo"); intent.setData(Uri.parse("http://www.baidu.com:6666/second?message=comesecondactivity")); startActivity(intent); break; default: break; &#125; &#125; GetStartDemo的清单文件中匹配对应的intent-filter 12345678&lt;intent-filter&gt; &lt;action android:name="com.dreamboat.startdemo"/&gt; &lt;category android:name="android.intent.category.DEFAULT"/&gt; &lt;data android:host="www.baidu.com" android:port="6666" android:scheme="http"/&gt; &lt;/intent-filter&gt; 主页面中判断跳转 12345678910111213141516Uri data = getIntent().getData(); if (data != null)&#123; String path = data.getPath(); String message = data.getQueryParameter("message"); if ("/first".equals(path))&#123; Intent intent=new Intent(this,FirstActivity.class); intent.putExtra("message",message); startActivity(intent); finish(); &#125;else if ("/second".equals(path))&#123; Intent intent=new Intent(this,SecondActivity.class); intent.putExtra("message",message); startActivity(intent); finish(); &#125; &#125; 效果如下 问横竖屏切换时候Activity的生命周期清单文件中不设置Activity的activity:configChanges时。切屏会重新回调每个生命周期，切横屏时会执行一次，切竖屏时会执行俩次。设置Activity的activity:configChanges=”orientation”时，切横竖屏走一次生命周期。设置Activity的activity:configChanges=”orintation|keyboardHidden”时，切屏不会重新调用各个生命周期，只会走onConfigurationChanged方法。切横屏时走一次onConfigurationChanged方法，切竖屏时走俩次。 ActivityA跳转ActivityB然后B按back返回A，各自的生命周期顺序，A不透明B透明。ActivityA跳转到ActivityB： 1234Activity A：onPauseActivity B：onCreateActivity B：onStartActivity B：onResume ActivityB返回ActivityA： 1234Activity B：onPauseActivity A：onResumeActivity B：onStopActivity B：onDestroy Android中跨进程通讯的几种方式1, 意图： 12Intent callIntent = new Intent(Intent.ACTION_CALL,Uri.parse("tel:12345678");startActivity(callIntent); 2,Content Provider3，广播4，AIDL服务 显示Intent与隐式Intent的区别对明确指出了目标组件名称的Intent，我们称之为“显式Intent”对于没有明确指出目标组件名称的Intent，则称之为“隐式 Intent”。对于隐式意图，在定义Activity时，指定一个intent-filter，当一个隐式意图对象被一个意图过滤器进行匹配时，将有三个方面会被参考到： 动作(Action) 多对1 类别(Category) 多对多 数据(Data ) 多对1 android的启动模式 到底在什么时候用 standard 普通activity singleTop 适合接收通知启动的内容显示页面 比如推送页面 自己跳转自己的页面 singleTask 适合程序开始的activity singleInstance 只做一件事情，无后续操作]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android开发艺术探索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[07Java复习-文件,IO流]]></title>
    <url>%2F2019%2F11%2F20%2F07Java%E5%A4%8D%E4%B9%A0-%E6%96%87%E4%BB%B6-IO%E6%B5%81%2F</url>
    <content type="text"><![CDATA[I/O概述 I/O:Input Output 输入输出]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[06Java复习--集合]]></title>
    <url>%2F2019%2F11%2F18%2F06Java%E5%A4%8D%E4%B9%A0-%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[参考资料： Java核心技术 卷一 Collection接口 概述 List下 有ArrayList,Vector,LinkedList; Set下 有HashSet,LinkedHashSet,TreeSet; Collection下还有个Queue接口，有ProorityQueue类 总结List 有序，可重复 ArrayList 底层数据结构是数组 特点：查询快，增删慢，线程不安全。 Vector 底层数数据结构是数组， 特点：线程安全，相比ArrayList慢，不考虑线程是否安全情况下被ArrayList取代 LinkedList 底层数据结构是链表（双向循环链表） 特点：增删快，查询慢，线程不安全 Set 无序，唯一 HashSet 底层数据结构是哈希表（无序，唯一） 如何保证元素唯一性：依赖hashCode()和equals() LinkedHashSet 底层数据结构是链表和哈希表（FIFO（先入先出）插入有序，唯一） 如何保证元素唯一性：哈希表 如何保证元素有序：链表 TreeSet 底层数据结构是红黑树（有序，唯一） 如何保证元素唯一性：根据比较的返回值是否为0来决定 如何保证元素的有序：自然排序，比较器排序 如何选择Colletction下接口 Map接口map接口不继承与Colletcion 是一个独立接口 它提供了一组键值的映射，其中存储的每一个对象都有一个相应的关键字（key）,关键字决定了对象在Map中的存储位置，关键字是唯一的。 概述 Map下几个重要的实现类：HashMap，TreeMap,HashTable等 HashMap: 实现原理：散列 键值对，key不能重复，value可以重复； key的实现就是HashSet； 允许null的键或值（键最多一条）； 线程不安全，想要安全可以用Collections的synchronizedMap方法使得HashMap安全 HashTable:线程安全，但不许null的键或值 TreeMap:对key排好序的Map;key就是TreeSet，value对应每个key，key要实现Comparable接口或TreeMap有自己的构造器 LinkedHashMap:此实现与HashMap的不同之处在于：HashMap维护着一个运行与所有条目的双重链接列表，存储的数据是有序的。Map集合比较 HashMao的存入顺序和输出顺序无关 LinkedHashMap 保留了键值对的存入顺序 TreeMap 是对Map中的元素进行排序，是根据key进行排序，所以，key中存放的对象必须实现Comparable接口 总结与面试主要特性ArrayList:元素单个，效率高，多用于查询Vector:元素单个，线程安全，多用于查询LinkedList:元素单个，多用于插入删除HashMap:元素成对，元素可为空HashTable:元素成对，线程安全，元素不可为空 HashMap和HashTable的区别 相同点 都是Java的集合类，都可以存储Java对象 不同点 HashTable是基于陈旧的Dictionary类，HashMap是Java1.2引进的Map接口的一个实现 HashTable 是同步的，HashMap是异步的。因此HashMap中的对象不是线程安全的 HashMap可以放入空值，HashTable不可以放入空值 ArrayList和Vector的区别 相同点 都是Java的集合类，都用来存放Java对象，底部数据结构都是数组实现 不同点 Vector是同步的，线程安全，ArrayList是异步的，线程不安全。 都是数组实现，但在缺省的情况下，Vector自增一倍，ArrayList自增50% ArrayList和LinkedList的区别 ArrayList底层数据结构是动态数组，LinkedList是链表 对于随机访问get和set，ArrayList优于LinkedList，因为后者要移动指针 对于新增和删除，LinkedList优于ArrayList。不过要看数据量，针对单条，ArrayList占优，批量LinkedList占优。 HashMap与TreeMap区别 HaspMap通过hashcode对其内容进行快速查找，TheeMap中所有元素都保持着某种固定的顺序。如果你需要得到一个有序的结果应该使用TreeMap 在Map中插入删除和定位元素，HashMap是最好的选择，但如果要使用自然顺序，或自定义顺序遍历键，TreeMap更好。 使用HashMap要求添加的键类明确定义了hashcode（）和equals（）的实现。 俩个map中的元素一样，但顺序不一样，会导致hashcode（）不一样。 性能和复杂度之后看过《数据结构》后会单独整理成篇]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[05Java复习--类与对象]]></title>
    <url>%2F2019%2F11%2F14%2F05Java%E5%A4%8D%E4%B9%A0-%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[参考资料： Java核心技术 卷一 面向对象概述 通过操作对象来达到用户需求 就说吃饭吧。饿了要吃东西，自己做饭的话，需要去买菜，洗菜，淘米，烹饪。这个是面向过程。面向对象的话，就是：媳妇，饿了，要吃排骨，你去做吧。媳妇，就是你对象（咦。。。）在Java里，我们就是操作一个个对象去完成各种需求的。 三大特性封装概述封装就是隐藏对象的属性和实现细节，对外公开接口，控制在程序中属性的读和修改的访问级别。将抽象得到的数据和行为相结合，形成一个整体（类） 这样，只能通过规定的方法来访问数据，隐藏了实现细节，提高了程序的安全性和可维护性 举例1234567891011121314public class OOPTest1 &#123; public String name; //公有的 protected String money; //受保护的 int height; //默认的 private int age; //私有的 public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; 无法直接获取age 继承概述继承就是子类继承父类的特征和行为，使得子类对象具有父类的实例域和方法，或类从父类继承方法，使得子类具有父类相同的行为 构造方法和private修饰的不能继承 举例 son继承father的吃饭和说话，还可重写 Android中常用的base类的书写 多态概述同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。也就是在编写程序时，并不能够确定引用变量所指向的具体类型和某个方法。只有当其运行期间才能够确定。 这样，不用修改程序代码，就可以让引用变量绑定到不同的类实现上，从而导致改引用调用的具体方法随之改变，让程序可以选择多个运行状态。这就是多态性 举个列子比如你去面试。桌子前，坐着3个面试官。开始面试前，你只能知道他们是该公司工作人员，并不能晓得他们具体的职位。只有当开始面试，他们开始自我介绍，或者问你问题时候，你才能知道，哦，这个问Java的是Java面试官，这个问Android的是Android面试官，这个问你理想的，是HR。。。 我们可以描述如下 工作人员 a= Java面试官 工作人员 b= Android面试官 工作人员 c= HR 这里所表现的就是多态。Java面试官等都是工作人员的子类。我们只有开始面试后，才能晓得他们具体的工种。通过工作人员一个父类就能够引用不同的子类。 这里需要明白一个概念：向上转型 继续面试的例子。工作人员（Work）是父类，Java面试官（Java），Android面试官（Android），HR（HR）是子类。我们定义如下： Java a=new Java(); 这个很好理解。就是直接new了一个Java面试官的对象。 Work a=new Java();这个呢？ 我们可以这样理解,我们定义了一个Wrok类型的a,他指向Java对象实例。由于Java是继承与Work的，所以Java自动向上转型为Work，所以a是可以指向Java实例对象的。这样我们定义的Java除了可以引用父类Work的共性外，还可以使用子类所扩展的功能。 但向上转型有一些缺陷，那就是它必定会导致一些方法和属性的丢失，我们不能获取到它。所以，父类类型的引用可以调用父类总定义的所有属性和方法，对于只存在与子类中的方法和属性，就无法获取到了。 1234567891011121314151617181920212223242526272829303132333435363738public class OOPTest &#123; public static void main(String[] args) &#123; Work a = new Java(); a.say(); &#125;&#125;class Work &#123; public void say() &#123; System.out.println(&quot;我为公司工作&quot;); work(); &#125; public void work() &#123; System.out.println(&quot;我工作，公司给我工资&quot;); &#125;&#125;class Java extends Work &#123; /** * 子类重载父类方法 * 父类中不存在该方法，向上转型后无法调取改方法 * @param a */ public void say(String a) &#123; System.out.println(&quot;我为公司写Java&quot;); work(); &#125; /** * 子类重写父类方法 * 调取时必定是调取该方法 */ public void work() &#123; System.out.println(&quot;我写Java，公司给我工资&quot;); &#125;&#125; 输出：我为公司工作/我写Java，公司给我工资 通过输出我们可以得知，a.say首先是运行父类Work中的say()方法，然后在运行子类Java中的work()方法。 分析：在这个程序中，子类Java重载了父类的say()，重写了work();而重载后的say(String a)和父类的say()不是一个方法，向上转型后会丢失改方法。而重写了work(),指向Java的Work会调用Java中的work(); 总结：指向子类的父类引用，由于向上转型了，它只能访问父类中存在的方法和属性，对于不存在的，是无法调用使用的，就算是重载该方法，也不可以。若子类重写了父类中的某些方法，在调用时，必定是调用的子类重写后的该方法（动态链接，动态调用）。 当超类对象引用变量 引用子类对象时，被引用对象的类型（不是引用变量的类型）决定了调用谁的成员方法。但是这个被调用的方法必须是在超类中定义过的。也就是说，被子类覆盖的方法。继承链中对象方法调用的优先级：this.show(O),super.show(O),this.show((super)0),super.show((super)O) 成员变量，静态方法：看左边 非静态方法：编译看左边，运行看右边 五大原则高内聚低耦合 单一职责（SRP）一个类只完成它应该完成的职责，不能越俎代庖，不能成为无所不能的上帝类。 开放封闭原则(OCP)软件实体应当对外扩展开放，对内修改闭合。也就是说，不能再修改一个类的前提下扩展这个类。 里式替换原则(LSP)子类型必须能够替换他们的基类型。也就是说，使用基类引用的地方必须能够使用继承类的对象，而不必知道它。 依赖倒置原则（DIP）高层模块不应该依赖底层模块。俩者都应该依赖其抽象。（面向接口编程） 接口分离原则（ISP）一个接口或者类应该尽可能少的行为。要明确，易理解，可复用。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[04Java复习--数组]]></title>
    <url>%2F2019%2F09%2F11%2F04Java%E5%A4%8D%E4%B9%A0--%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[今天最好的表现是明天最低的要求 参考资料：Java核心技术 卷一 数组基本概念数组是一种数据结构，用来存储同一类型的集合。通过下标，可以访问数组中的每一个值。 为什么要使用数组1，单一值类型变量有时难以满足应用程序的设计要求比如你要定义100个整型变量，那么如果不使用数组，可能需要： 1int i1,i2,i3....i100; 如果要输出这100个变量，那。。 2，可以自动给数组中的元素从0开始编号，方便操作这些元素 数组的初始化 动态初始化 声明并开辟数组 数据类型[] 数组名称 = new 数据类型[长度] （常用） 数据类型 数组名称[] = new 数据类型[长度] 分步声明开辟数组 数据类型[] 数组名称=null 数据名称 = new 数据类型[长度] 1234567891011121314151617181920212223public class Main &#123; public static void main(String[] args) &#123; //动态声明开辟 int[] a = new int[2]; a[0] = 1; a[1] = 2; for (int i = 0; i &lt; a.length; i++) &#123; System.out.println(a[i]); &#125; int b[] = new int[2]; b[0] = 3; b[1] = 4; for (int x : b) &#123; System.out.println(x); &#125; //动态声明开辟-分步 int[] c = null; c = new int[2]; c[0] = 5; c[1] = 6; System.out.println(Arrays.toString(c)); &#125;&#125; 静态初始化 数据类型 数组名称 =new 数据类型{值1，值2} 数据类型 数组名称={值1，值2} 不论怎么初始化，一定是声明+开辟空间，因为数组属于引用类型。不开辟空间的话，无法在堆内存中找到，会出现NullPointerException异常 数组的排序和最值获取最值12345678910111213141516171819202122public class Main &#123; public static void main(String[] args) &#123; //获取最大值最小值 int[] a = &#123;22, 55, 34, 78, 203, 3, 5&#125;; //声明最大最小值 int max = a[0]; int min = a[0]; //比较记录 for (int i = 0; i &lt; a.length; i++) &#123; if (a[i] &gt; max) &#123; max = a[i]; &#125; &#125; for (int i = 0; i &lt; a.length; i++) &#123; if (a[i] &lt; min) &#123; min = a[i]; &#125; &#125; System.out.println(&quot;最大值=&quot; + max); System.out.println(&quot;最小值=&quot; + min); &#125;&#125; Arrays.sort(）12345678910111213141516171819202122232425262728public class Main &#123; public static void main(String[] args) &#123; Integer[] a = &#123;22, 55, 34, 78, 203, 3, 5&#125;; //优化的快速排序方法（串行排序）Build completed successfully in 2 s 722 ms Arrays.sort(a); System.out.println(Arrays.toString(a)); //优化的快速排序方法（并行排序）性能和串行比较高 Build completed successfully in 2 s 666 ms Arrays.parallelSort(a); System.out.println(Arrays.toString(a)); //从大大小排序 Build completed successfully in 2 s 777 ms Comparator comparator = new MyComparator(); Arrays.sort(a, comparator); System.out.println(Arrays.toString(a)); &#125; static class MyComparator implements Comparator&lt;Integer&gt; &#123; @Override public int compare(Integer o1, Integer o2) &#123; if (o1 &lt; o2) &#123; return 1; &#125; else if (o1 &gt; o2) &#123; return -1; &#125; else &#123; return 0; &#125; &#125; &#125;&#125; 输出结果： 排序回顾完集合后会单独整理一篇排序]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[03Java复习--控制流程]]></title>
    <url>%2F2019%2F08%2F12%2F03Java%E5%A4%8D%E4%B9%A0--%E6%8E%A7%E5%88%B6%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[参考资料：Java核心技术 卷一 与任何程序设计语言一样，Java使用条件语句和循环结构来确定控制流程 块作用域块是指由一对大括号括起来的若干条简单的Java语句,块确定了变量的作用域，不可在嵌套的俩个块中声明同名的变量 1234567public static void mian(String[] str) &#123; int n; &#123; int k; int n;//不可声明，Variable &apos;n&apos; is already defined in the scope &#125; &#125; 条件语句 if if,如果 if(条件){},执行语句一条时，中括号可省略 12345678910public class Main &#123; public static void main(String[] args) &#123; int a=6; if(a&gt;5)&#123; System.out.println(&quot;我比5大&quot;); &#125;else &#123; System.out.println(&quot;我比5小&quot;); &#125; &#125;&#125; 输出结果： 循环while while(条件){输出} 123456789public class Main &#123; public static void main(String[] args) &#123; int a=1; while (a&lt;10)&#123; a++; System.out.println(a); &#125; &#125;&#125; while，一直循环，直到变量a自增到大于10while 语句会首先检测条件，当条件不满足时，代码不会被执行。所以如果需要至少执行一次代码的话，应该把条件放到最后。使用do while do while123456789public class Main &#123; public static void main(String[] args) &#123; int a=1; do&#123; System.out.println(a); a++; &#125;while (a&lt;5); &#125;&#125; 先执行一次代码，在进行判断 确定循环 for根据块的概念，循环有其单独的作用域（{}之内） 1234for (int i = 0; i &lt;10 ; i++) &#123; //执行语句 //第一部分：计数器初始化 第二部分：条件 第三部分如何更新计数器 &#125; 循环嵌套嵌套循环及双层/多层循环进行嵌套 打印一个正方形 123456for (int i = 0; i &lt;10 ; i++) &#123; for (int j = 0; j &lt; 10; j++) &#123; System.out.print(&quot; *&quot;); &#125; System.out.println();//换行 &#125; 打印一个直角三角形 123456for (int i = 1; i &lt;10 ; i++) &#123; for (int j = 0; j &lt; i; j++) &#123; System.out.print(&quot; *&quot;); &#125; System.out.println();//换行 &#125; for each 循环（增强for循环）结构：for(int k:a) 1for(变量类型 变量名：数组名)&#123; 执行语句&#125; for循环是通过循环控制变量，访问数组中不同位置处的元素进行遍历 for-each循环是依次处理数组中的元素，不必为指定下标值分心 下面是一个使用for-each循环寻找数组内元素的例子 1234567891011121314151617public class Main &#123; public static void main(String[] args) &#123; int [] a=new int [10];//新建长度为10的数组 for (int i = 0; i &lt; a.length; i++) &#123;//给数组赋值 a[i]=i; &#125; int b=5; for(int c:a)&#123; if(c==b)&#123; System.out.println(&quot;找到了 c=&quot;+c); &#125;else &#123; System.out.println(&quot;没找到&quot;); &#125; &#125; &#125;&#125; 输出：如果只需找到数组中是否有某个元素，而不返回对应下标，使用for-each循环更加简洁，不易出错。 如果只是单纯想打印数组中的元素,可以使用Arrays.toString(); 多重选择 switch1234567891011switch (表达式) &#123; case 取值1: //char byte short或int的常量表达式 //枚举常量 //Java SE7 开始可用字符串 break; //最终执行 default: break; &#125; 中断控制流程语句goto是拙劣的，Java虽未删除，但依旧没使用它。 但跳出循环还是需要的，使用其他的代替 break12345678public class Main &#123; public static void main(String[] args) &#123; for (int i = 1; i &lt;10 ; i++) &#123; System.out.print(i); break; &#125; &#125;&#125; 输出结果当代码执行循环第一次时，break就执行了，不再进行之后的循环 continue1234567891011public class Main &#123; public static void main(String[] args) &#123; for (int i = 0; i &lt;10 ; i++) &#123; if(i%2==1)&#123; continue; &#125; System.out.println(i); &#125; &#125;&#125; 输出结果 当i % 2 == 1时，程序正常循环，否则终止本次循环，直接开启下次循环]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义StringBuilder和StringBuffer]]></title>
    <url>%2F2019%2F08%2F01%2F%E8%87%AA%E5%AE%9A%E4%B9%89StringBuilder%E5%92%8CStringBuffer%2F</url>
    <content type="text"><![CDATA[根据上篇得出的规律 初始默认长度16或自定义 扩增规律：原有容量*2+2 StingBuilder和StringBuffer都继承与AbstractStringBuilder，且AbstractStringBuilder不可由外部调用。所以首先写一个MyAbstractStringBuilder类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public class MyAbsractStringBuilder &#123; /** * 存储字符的数组 */ char[] value; /** * 记录append操作，添加字符的数量 */ int count; /** * 无参构造 */ MyAbsractStringBuilder() &#123; &#125; /** * @param capacity 为char 数组定义大小 */ MyAbsractStringBuilder(int capacity) &#123; value = new char[capacity]; &#125; public MyAbsractStringBuilder append(String str) &#123; if (str == null) &#123; value = new char[0]; return this; &#125; int len = str.length();//获取新添加字符的长度 ensureCapacityInternal(count + len);//已知新字符的长度，若超出原数组长度，在原有的基础上创建（扩充）一个新的容器（数组） str.getChars(0, len, value, count);//使用string的getchars方法将字符从该字符串复制到value数组中 count += len;//count 长度 return this; &#125; private void ensureCapacityInternal(int needCapacity) &#123; if (needCapacity &gt; value.length) &#123;//现有数组容量不满足 value = Arrays.copyOf(value, newCapacity(needCapacity));//创建新的数组 参数2：新的数组的长度 &#125; &#125; private int newCapacity(int needCapacity) &#123; int newCapacity = (value.length * 2) + 2;//定义新的容量，原有容量*2+2 if (newCapacity &lt; needCapacity) &#123; //如果新容量小于所需容量，新容量=所需容量 newCapacity = needCapacity; &#125; // 数组分配最大大小，超过最大限制可能会导致OutOfMemoryError return newCapacity &gt; Integer.MAX_VALUE - 8 ? newCapacity : Integer.MAX_VALUE - 8; &#125; /** * @return 长度 */ public int length() &#123; return count; &#125; /** * @return 容量 */ public int capacity() &#123; return value.length; &#125; /** * @return 字符串 */ public String toString() &#123; return new String(value, 0, count); &#125;&#125; 定义MyStringBuilder类继承MyAbsractStringBuilder 1234567891011121314151617181920212223242526272829public class MyStringBuilder extends MyAbsractStringBuilder &#123; MyStringBuilder() &#123; super(16); &#125; MyStringBuilder(int capacity) &#123; super(capacity); &#125; @Override public MyAbsractStringBuilder append(String str) &#123; return super.append(str); &#125; @Override public int length() &#123; return super.length(); &#125; @Override public int capacity() &#123; return super.capacity(); &#125; @Override public String toString() &#123; return super.toString(); &#125;&#125; 主函数调用 12345MyStringBuilder myStringBuilder=new MyStringBuilder(); myStringBuilder.append(&quot;myStringBuilder&quot;); LogUtils.e(&quot;myStringBuilder的长度&quot;+myStringBuilder.length()); LogUtils.e(&quot;myStringBuilder的容量&quot;+myStringBuilder.capacity()); LogUtils.e(&quot;---&quot;+myStringBuilder.toString()); log打印 StringBuffer与StringBuilder 不同的是，方法需要加同步锁 123456789101112131415161718192021222324252627282930public class MyStringBuffer extends MyAbsractStringBuilder&#123; MyStringBuffer() &#123; super(16); &#125; MyStringBuffer(int capacity) &#123; super(capacity); &#125; @Override public synchronized MyAbsractStringBuilder append(String str) &#123; return super.append(str); &#125; @Override public synchronized int length() &#123; return super.length(); &#125; @Override public synchronized int capacity() &#123; return super.capacity(); &#125; @Override public synchronized String toString() &#123; return super.toString(); &#125;&#125;]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[02Java复习--Java基本程序设计结构]]></title>
    <url>%2F2019%2F06%2F26%2F02Java%E5%A4%8D%E4%B9%A0--Java%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[参考资料：Java核心技术 卷一 基本的Java设计结构12345678// 公共的 类 类名 public class FirstJava &#123;//公共的 静态的 无返回值 main方法 数组 public static void main (String[] args) &#123; //输出语句 System.out.printIn(&quot;Hello World&quot;); &#125; &#125; 访问修饰符 publish 可以被任何类访问 protected 可以被同一个包中的所有类访问 private 只能被当前类的方法访问 缺省 可以被同一包中的所有类访问 类名 驼峰命名 不能用关键字 其他命名规范 包 最好是域名倒过来，所有字母小写 接口 驼峰命名 不能用关键字 方法或变量 如果是一个单子全部小写 如果是多个单词，从第二个单词开始首字母大写 常量 如果是一个单词，所有字母大写 如果是多个单词，所有的单词大写，用下划线分离每个单词 注释12345单行注释 //多行注释/** * */ 数据类型byte 整型 占一个字节 8位，最大存储数据量是255.存放的数据范围是-128-127之间 封装器类 Byte short 整形 占俩个字节 16位，最大数据存储量是65536^-^,数据范围是-32768-32767之间 封装器类 Short int 整形 占四个字节 32位，最大数据存储容量是2的32次方-1，数据范围是负的2的1次方到正的2的31次 long 整形 占八个字节 64位，最大数据存储容量是2的64次方-1数据范围是负的0的63次方到挣得2的64次方减一 float 浮点型 占四个字节 32位，数据范围在正负3.4E+38F 必须有后缀 f或F double 浮点型 占八个字节 64位 boolean 只有true和false 俩个值 char 16位 存储Unicode码 用单引号复制 变量 每一个变量都有一个类型（type） 变量是可以重复复制的 大小写敏感，不可用Java保留字 建议逐一声明 常量 利用关键字final指示常量 只能被赋值一次 常量名全部大写，多个单词下划线连接 运算符算数运算符 简单的+ - x / % 需注意，整数不可被0整除，浮点数被0整除会得到无穷大或者NaN的结果 赋值运算符 +=;-=;*=;/=;%=; 把左边的和右边的做XX法然后赋值给左边。一般把运算符放在=左边 比较运算符 &lt;;&gt;;==等 返回值true或false 逻辑运算符 &amp; 1234567/** * true &amp; true true * true &amp; false false * false &amp; true false * false &amp; false false * 总结：&amp;符号就是你两边都是true才成立，换句话说，两边只要有一个false，就是false */ | 12345678/** * true | true true * true | false true * false | true true * false | false false * * 总结：只要就一个成立就可以，也就是返回true，只有当两个都是false才会返回false */ ^ 1和|差不多，除了 true^true= false ！ 123非int a=1;!a=2; 返回true &amp;&amp; 1从左到右，只要有false 后面就不执行了 || 1从左到右，只要有true 后面就不执行了 位运算符 &lt;&lt;左移 &gt;&gt;右移 &gt;&gt;&gt;无符号右移 &amp;与运算 |或运算 ^异和运算 ~反码 二进制运算，需懂进制转换 效率（计算机实际上在内存中也是讲数字转换成二进制进行计算） 三元运算符 （条件表达式）? 表达式1（true）：表达式2（false） 字符串 概念上讲 Java字符串就是Unicode字符序列 提取自串 substring 比较 equals String使用字符数组保存,有final修饰符，不可变,可理解为常量，所以线程安全 equals与==的区别前提：在JVM中，内存分为堆内存和栈内存。二者的区别是：当我们创建一个对象时，就会调用对象的构造函数来开辟空间。将对象的数据存储在堆内存中，与此同时，在栈内存中生成对应的引用。当我们后续使用该对象时候，调用的都是栈内存中的引用。 1,==是判断俩个变量或实例是不是指向同一个内存空间，equals是判断俩个变量或实例所指向的内存空间的值是不是相同2，==是指对内存地址进行比较，equals是对字符串内容进行比较3，==指引用是否相同，equals指的是值是否相同 注意：基本数据类型是存储在栈内存中，==比较基本数据类型时比较的是值。 常用String Api int index0f() 如果原字符串中不存在。返回-1 subString 获取子串 trim 去除首尾空白字符 构建字符串StringBuilder 继承自AbstractStringBuilder，使用字符数组保存字符串。可变 未对方法添加同步锁，线程不安全 如果程序不是多线程的，那么StringBuilder效率高于StringBuffer StringBuffer 继承自AbstractStringBuilder，使用字符数组保存字符串。可变 对方法或者对调用的方法加了同步锁，线程安全 capacity()方法容量问题1234567891011121314151617StringBuilder builder=new StringBuilder(); builder.append(&quot;capacity&quot;); LogUtils.e(&quot;capacity的长度&quot;+builder.length()); LogUtils.e(&quot;capacity的容量&quot;+builder.capacity());StringBuilder builder1=new StringBuilder(); builder1.append(&quot;capacity超过16超过16超过16&quot;); LogUtils.e(&quot;capacity超过16的长度&quot;+builder1.length()); LogUtils.e(&quot;capacity超过16的长度的容量&quot;+builder1.capacity()); for (int i = 0; i &lt; 4; i++) &#123; LogUtils.e(&quot;-------------------&quot;+i+&quot;---------------------&quot;); builder1.append(&quot;capacity超过16超过16超过16&quot;); LogUtils.e(&quot;capacity超过16的长度&quot;+builder1.length()); LogUtils.e(&quot;capacity超过16的长度的容量&quot;+builder1.capacity()); &#125; 可以看出，当为缺省构造时，且不超过16时，默认容量为16，超过时在原有的基础上*2+2; 1234StringBuilder builder2=new StringBuilder(10);builder2.append(&quot;capacity&quot;);LogUtils.e(&quot;capacity的长度&quot;+builder2.length()); LogUtils.e(&quot;capacity的容量&quot;+builder2.capacity()); 当为有参构造时，不使用默认长度容量，自定义初始容量。超过16时与缺省构造相同 自定义StringBuilder和StringBuffer]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[01Java复习--基本常识，Java概念]]></title>
    <url>%2F2019%2F05%2F15%2F01Java%E5%A4%8D%E4%B9%A0--%E5%9F%BA%E6%9C%AC%E5%B8%B8%E8%AF%86%EF%BC%8CJava%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[参考资料： Java核心技术 卷一https://blog.csdn.net/simplebam/article/details/65447600 基本常识什么是软件 软件：一系列按照特定组织的计算机数据和指令的集合 常用CDM命令 dir:列出当前目录下的文件及文件夹（ md:创建目录 rd:删除目录 cd:进入指定目录 cd ..:退回到上一级目录 cd\:退回到根目录 del(delete):删除文件 exit:退出dos命令行 cls(clear screen)：清屏 Mac常用命令 cd:进入指定目录 ls:列出当前目录下的所有文件 pwd:显示当前目录路径 mkdir:新建目录 rmdir:删除目录 env: 显示当前所有设置过的环境变量 Java概念什么是Java Java是一门面向对象编程语言，95年sun公司发布。 Java的优点简单性 风格类似于C++,缺摒弃了C++中一些很少用到的特征，比如go to 语句，Java也没有头文件，指针运算等。 Java提供了丰富的类库 面向对象OOP 基本概念 对象 对象是人们要进行研究的任何事物，不仅能表示具体的事物，还能表示抽象的规则、计划或事件 对象的状态和行为 具有相同或相似性质的对象的抽象就是类，因此，对象的抽象是类，类的具体化就是对象，也可以说类的实例是对象。 类具有属性，他是对象的状态的抽象，用数据结构来描述类的属性 类具有操作，他是对象的行为的抽象，用操作名和实现该操作的方法来描述 类的结构 一般：具体结构成为分类结构，也可以说是“或”关系，或者是”is a“关系 整体：不跟结构成为组装结构，他们之间的关系是一种”与“关系，或者是”has a“关系 消息和方法 对象直接进行通信的结构叫做消息 类中操作的实现过程叫做方法。 三大特性 封装：隐藏对象的属性和实现细节，仅对外提供公共访问方式，将变化隔离，便于使用，提高复用性和安全性 继承：提高代码复用性；继承是多态的前提 多态：父类或接口定义的引用变量可以指向子类或具体实现类的实例对象，提高了程序的拓展性。 五大基本原则 单一职责原则（SRP）:类的功能要单一 开放封闭原则（OCP）:一个模块对于拓展是开放的，对于修改是封闭的 里式替换原则（LSP）:子类可以替换父类出现在父类能够出现的任何地方 依赖倒置原则（DIP）:高层次的模块不应该依赖低层次的模块，他们都应该依赖于抽象。抽象不应该依赖于具体实现，具体实现应该依赖于抽象。 接口分离原则（ISP）:设计采用多个特定客户类有关的接口比采用一个通用的接口要好。 总结 面向对象：易维护，易复用，易拓展，低耦合。 面向过程：性能高，耗资源 分布式 Java有一个丰富的例程库，用于处理像HTTP和FTP之类的TCP/IP协议。Java程序可以通过URL打开和访问网络上的对象 健壮性 早期问题检测、运行时检测 Java和C++最大的不同在于Java采用的指针模型可以消除重写内存和损坏数据的可能 安全性 防病毒–运行时堆栈溢出，如蠕虫和病毒常用的攻击手段 防篡改–未经授权不可读写文件，除非有数字签名 存储分配模型–Java没有指针，所有无法得到隐藏起来的内幕，也无法伪造指针去指向存储器。Java编译程序不处理存储安排决策（由Java解释程序决定），所以程序猿不能通过查看声明去猜测类的实际存储安排。 体系结构中立（编译和解释性） Java程序可以在任何实现了Java解释程序和运行系统的系统上运行 可移植性 Java规范中没有“依赖具体实现”的方法 基本数据类型的大小和范围都做了明确的说明 高性能 即时编译 多线程性 Java是第一个支持并发程序设计的主流语言 动态性 Java中的类是根据需要载入的，甚至有些是通过Internet获取的]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java基础</tag>
      </tags>
  </entry>
</search>
