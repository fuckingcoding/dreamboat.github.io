<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[自定义StringBuilder和StringBuffer]]></title>
    <url>%2F2019%2F08%2F01%2F%E8%87%AA%E5%AE%9A%E4%B9%89StringBuilder%E5%92%8CStringBuffer%2F</url>
    <content type="text"><![CDATA[根据上篇得出的规律 初始默认长度16或自定义 扩增规律：原有容量*2+2 StingBuilder和StringBuffer都继承与AbstractStringBuilder，且AbstractStringBuilder不可由外部调用。所以首先写一个MyAbstractStringBuilder类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public class MyAbsractStringBuilder &#123; /** * 存储字符的数组 */ char[] value; /** * 记录append操作，添加字符的数量 */ int count; /** * 无参构造 */ MyAbsractStringBuilder() &#123; &#125; /** * @param capacity 为char 数组定义大小 */ MyAbsractStringBuilder(int capacity) &#123; value = new char[capacity]; &#125; public MyAbsractStringBuilder append(String str) &#123; if (str == null) &#123; value = new char[0]; return this; &#125; int len = str.length();//获取新添加字符的长度 ensureCapacityInternal(count + len);//已知新字符的长度，若超出原数组长度，在原有的基础上创建（扩充）一个新的容器（数组） str.getChars(0, len, value, count);//使用string的getchars方法将字符从该字符串复制到value数组中 count += len;//count 长度 return this; &#125; private void ensureCapacityInternal(int needCapacity) &#123; if (needCapacity &gt; value.length) &#123;//现有数组容量不满足 value = Arrays.copyOf(value, newCapacity(needCapacity));//创建新的数组 参数2：新的数组的长度 &#125; &#125; private int newCapacity(int needCapacity) &#123; int newCapacity = (value.length * 2) + 2;//定义新的容量，原有容量*2+2 if (newCapacity &lt; needCapacity) &#123; //如果新容量小于所需容量，新容量=所需容量 newCapacity = needCapacity; &#125; // 数组分配最大大小，超过最大限制可能会导致OutOfMemoryError return newCapacity &gt; Integer.MAX_VALUE - 8 ? newCapacity : Integer.MAX_VALUE - 8; &#125; /** * @return 长度 */ public int length() &#123; return count; &#125; /** * @return 容量 */ public int capacity() &#123; return value.length; &#125; /** * @return 字符串 */ public String toString() &#123; return new String(value, 0, count); &#125;&#125; 定义MyStringBuilder类继承MyAbsractStringBuilder 1234567891011121314151617181920212223242526272829public class MyStringBuilder extends MyAbsractStringBuilder &#123; MyStringBuilder() &#123; super(16); &#125; MyStringBuilder(int capacity) &#123; super(capacity); &#125; @Override public MyAbsractStringBuilder append(String str) &#123; return super.append(str); &#125; @Override public int length() &#123; return super.length(); &#125; @Override public int capacity() &#123; return super.capacity(); &#125; @Override public String toString() &#123; return super.toString(); &#125;&#125; 主函数调用 12345MyStringBuilder myStringBuilder=new MyStringBuilder(); myStringBuilder.append(&quot;myStringBuilder&quot;); LogUtils.e(&quot;myStringBuilder的长度&quot;+myStringBuilder.length()); LogUtils.e(&quot;myStringBuilder的容量&quot;+myStringBuilder.capacity()); LogUtils.e(&quot;---&quot;+myStringBuilder.toString()); log打印 StringBuffer与StringBuilder 不同的是，方法需要加同步锁 123456789101112131415161718192021222324252627282930public class MyStringBuffer extends MyAbsractStringBuilder&#123; MyStringBuffer() &#123; super(16); &#125; MyStringBuffer(int capacity) &#123; super(capacity); &#125; @Override public synchronized MyAbsractStringBuilder append(String str) &#123; return super.append(str); &#125; @Override public synchronized int length() &#123; return super.length(); &#125; @Override public synchronized int capacity() &#123; return super.capacity(); &#125; @Override public synchronized String toString() &#123; return super.toString(); &#125;&#125;]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java复习（二）--Java基本程序设计结构]]></title>
    <url>%2F2019%2F06%2F26%2FJava%E5%9F%BA%E7%A1%80%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[参考资料：Java核心技术 卷一 基本的Java设计结构12345678// 公共的 类 类名 public class FirstJava &#123;//公共的 静态的 无返回值 main方法 数组 public static void main (String[] args) &#123; //输出语句 System.out.printIn(&quot;Hello World&quot;); &#125; &#125; 访问修饰符 publish 可以被任何类访问 protected 可以被同一个包中的所有类访问 private 只能被当前类的方法访问 缺省 可以被同一包中的所有类访问 类名 驼峰命名 不能用关键字 其他命名规范 包 最好是域名倒过来，所有字母小写 接口 驼峰命名 不能用关键字 方法或变量 如果是一个单子全部小写 如果是多个单词，从第二个单词开始首字母大写 常量 如果是一个单词，所有字母大写 如果是多个单词，所有的单词大写，用下划线分离每个单词 注释12345单行注释 //多行注释/** * */ 数据类型byte 整型 占一个字节 8位，最大存储数据量是255.存放的数据范围是-128-127之间 封装器类 Byte short 整形 占俩个字节 16位，最大数据存储量是65536^-^,数据范围是-32768-32767之间 封装器类 Short int 整形 占四个字节 32位，最大数据存储容量是2的32次方-1，数据范围是负的2的1次方到正的2的31次 long 整形 占八个字节 64位，最大数据存储容量是2的64次方-1数据范围是负的0的63次方到挣得2的64次方减一 float 浮点型 占四个字节 32位，数据范围在正负3.4E+38F 必须有后缀 f或F double 浮点型 占八个字节 64位 boolean 只有true和false 俩个值 char 16位 存储Unicode码 用单引号复制 变量 每一个变量都有一个类型（type） 变量是可以重复复制的 大小写敏感，不可用Java保留字 建议逐一声明 常量 利用关键字final指示常量 只能被赋值一次 常量名全部大写，多个单词下划线连接 运算符算数运算符 简单的+ - x / % 需注意，整数不可被0整除，浮点数被0整除会得到无穷大或者NaN的结果 赋值运算符 +=;-=;*=;/=;%=; 把左边的和右边的做XX法然后赋值给左边。一般把运算符放在=左边 比较运算符 &lt;;&gt;;==等 返回值true或false 逻辑运算符 &amp; 1234567/** * true &amp; true true * true &amp; false false * false &amp; true false * false &amp; false false * 总结：&amp;符号就是你两边都是true才成立，换句话说，两边只要有一个false，就是false */ | 12345678/** * true | true true * true | false true * false | true true * false | false false * * 总结：只要就一个成立就可以，也就是返回true，只有当两个都是false才会返回false */ ^ 1和|差不多，除了 true^true= false ！ 123非int a=1;!a=2; 返回true &amp;&amp; 1从左到右，只要有false 后面就不执行了 || 1从左到右，只要有true 后面就不执行了 位运算符 &lt;&lt;左移 &gt;&gt;右移 &gt;&gt;&gt;无符号右移 &amp;与运算 |或运算 ^异和运算 ~反码 二进制运算，需懂进制转换 效率（计算机实际上在内存中也是讲数字转换成二进制进行计算） 三元运算符 （条件表达式）? 表达式1（true）：表达式2（false） 字符串 概念上讲 Java字符串就是Unicode字符序列 提取自串 substring 比较 equals String使用字符数组保存,有final修饰符，不可变,可理解为常量，所以线程安全 equals与==的区别前提：在JVM中，内存分为堆内存和栈内存。二者的区别是：当我们创建一个对象时，就会调用对象的构造函数来开辟空间。将对象的数据存储在堆内存中，与此同时，在栈内存中生成对应的引用。当我们后续使用该对象时候，调用的都是栈内存中的引用。 1,==是判断俩个变量或实例是不是指向同一个内存空间，equals是判断俩个变量或实例所指向的内存空间的值是不是相同2，==是指对内存地址进行比较，equals是对字符串内容进行比较3，==指引用是否相同，equals指的是值是否相同 注意：基本数据类型是存储在栈内存中，==比较基本数据类型时比较的是值。 常用String Api int index0f() 如果原字符串中不存在。返回-1 subString 获取子串 trim 去除首尾空白字符 构建字符串StringBuilder 继承自AbstractStringBuilder，使用字符数组保存字符串。可变 未对方法添加同步锁，线程不安全 如果程序不是多线程的，那么StringBuilder效率高于StringBuffer StringBuffer 继承自AbstractStringBuilder，使用字符数组保存字符串。可变 对方法或者对调用的方法加了同步锁，线程安全 capacity()方法容量问题1234567891011121314151617StringBuilder builder=new StringBuilder(); builder.append(&quot;capacity&quot;); LogUtils.e(&quot;capacity的长度&quot;+builder.length()); LogUtils.e(&quot;capacity的容量&quot;+builder.capacity());StringBuilder builder1=new StringBuilder(); builder1.append(&quot;capacity超过16超过16超过16&quot;); LogUtils.e(&quot;capacity超过16的长度&quot;+builder1.length()); LogUtils.e(&quot;capacity超过16的长度的容量&quot;+builder1.capacity()); for (int i = 0; i &lt; 4; i++) &#123; LogUtils.e(&quot;-------------------&quot;+i+&quot;---------------------&quot;); builder1.append(&quot;capacity超过16超过16超过16&quot;); LogUtils.e(&quot;capacity超过16的长度&quot;+builder1.length()); LogUtils.e(&quot;capacity超过16的长度的容量&quot;+builder1.capacity()); &#125; 可以看出，当为缺省构造时，且不超过16时，默认容量为16，超过时在原有的基础上*2+2; 1234StringBuilder builder2=new StringBuilder(10);builder2.append(&quot;capacity&quot;);LogUtils.e(&quot;capacity的长度&quot;+builder2.length()); LogUtils.e(&quot;capacity的容量&quot;+builder2.capacity()); 当为有参构造时，不使用默认长度容量，自定义初始容量。超过16时与缺省构造相同 自定义StringBuilder和StringBuffer]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java复习（一）--基本常识，Java概念]]></title>
    <url>%2F2019%2F05%2F15%2FJava%E5%9F%BA%E7%A1%80%E4%B8%80%2F</url>
    <content type="text"><![CDATA[参考资料： Java核心技术 卷一https://blog.csdn.net/simplebam/article/details/65447600 基本常识什么是软件 软件：一系列按照特定组织的计算机数据和指令的集合 常用CDM命令 dir:列出当前目录下的文件及文件夹（ md:创建目录 rd:删除目录 cd:进入指定目录 cd ..:退回到上一级目录 cd\:退回到根目录 del(delete):删除文件 exit:退出dos命令行 cls(clear screen)：清屏 Mac常用命令 cd:进入指定目录 ls:列出当前目录下的所有文件 pwd:显示当前目录路径 mkdir:新建目录 rmdir:删除目录 env: 显示当前所有设置过的环境变量 Java概念什么是Java Java是一门面向对象编程语言，95年sun公司发布。 Java的优点简单性 风格类似于C++,缺摒弃了C++中一些很少用到的特征，比如go to 语句，Java也没有头文件，指针运算等。 Java提供了丰富的类库 面向对象OOP 基本概念 对象 对象是人们要进行研究的任何事物，不仅能表示具体的事物，还能表示抽象的规则、计划或事件 对象的状态和行为 具有相同或相似性质的对象的抽象就是类，因此，对象的抽象是类，类的具体化就是对象，也可以说类的实例是对象。 类具有属性，他是对象的状态的抽象，用数据结构来描述类的属性 类具有操作，他是对象的行为的抽象，用操作名和实现该操作的方法来描述 类的结构 一般：具体结构成为分类结构，也可以说是“或”关系，或者是”is a“关系 整体：不跟结构成为组装结构，他们之间的关系是一种”与“关系，或者是”has a“关系 消息和方法 对象直接进行通信的结构叫做消息 类中操作的实现过程叫做方法。 三大特性 封装：隐藏对象的属性和实现细节，仅对外提供公共访问方式，将变化隔离，便于使用，提高复用性和安全性 继承：提高代码复用性；继承是多态的前提 多态：父类或接口定义的引用变量可以指向子类或具体实现类的实例对象，提高了程序的拓展性。 五大基本原则 单一职责原则（SRP）:类的功能要单一 开放封闭原则（OCP）:一个模块对于拓展是开放的，对于修改是封闭的 里式替换原则（LSP）:子类可以替换父类出现在父类能够出现的任何地方 依赖倒置原则（DIP）:高层次的模块不应该依赖低层次的模块，他们都应该依赖于抽象。抽象不应该依赖于具体实现，具体实现应该依赖于抽象。 接口分离原则（ISP）:设计采用多个特定客户类有关的接口比采用一个通用的接口要好。 总结 面向对象：易维护，易复用，易拓展，低耦合。 面向过程：性能高，耗资源 分布式 Java有一个丰富的例程库，用于处理像HTTP和FTP之类的TCP/IP协议。Java程序可以通过URL打开和访问网络上的对象 健壮性 早期问题检测、运行时检测 Java和C++最大的不同在于Java采用的指针模型可以消除重写内存和损坏数据的可能 安全性 防病毒–运行时堆栈溢出，如蠕虫和病毒常用的攻击手段 防篡改–未经授权不可读写文件，除非有数字签名 存储分配模型–Java没有指针，所有无法得到隐藏起来的内幕，也无法伪造指针去指向存储器。Java编译程序不处理存储安排决策（由Java解释程序决定），所以程序猿不能通过查看声明去猜测类的实际存储安排。 体系结构中立（编译和解释性） Java程序可以在任何实现了Java解释程序和运行系统的系统上运行 可移植性 Java规范中没有“依赖具体实现”的方法 基本数据类型的大小和范围都做了明确的说明 高性能 即时编译 多线程性 Java是第一个支持并发程序设计的主流语言 动态性 Java中的类是根据需要载入的，甚至有些是通过Internet获取的]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java基础</tag>
      </tags>
  </entry>
</search>
